import numpy as np
import numpy.typing as npt
from scipy.stats import multinomial


class tester:
	"""
	Testing class for performing Multinomial Tests using Monte Carlo simulation.

	Tests whether a given set of data, X, could have been generated by a
	hypothesised multinomial distribution.
	The distribution is parametrised by the number of bins in the multinomial
	distribution, K, the probability associated witheach case, p_i, and the total
	number of observations in each of the K bins, N.

	When the test is run, a number of random samples are drawn from the
	hypothesised distribution. The probability of X under the hypothesised
	distribution is then compared to the sampled data and from this a p-value is
	calculated and returned.

	Attributes
	----------
	n_samples : int, default=1000
		The number of Monte Carlo samples to generate
	statistics : numpy.ndarray[float]
		The probability of the Monte Carlo samples
	fix : bool, default=False
		If True, the statistics will not be recalculated upon restarting the test.
		Useful while testing or if multiple data sets need to be tested under the
		same hypothesis (beware of bias!).

	Methods
	-------
	do_test(x, probs)
		Calculate p-value for a dataset being generated by the given multinomial
		distribution.

	Examples
	--------
	Test some sample D6-rolling data
	>>> t = mmct.tester()
	>>> t.n_samples = 80000
	>>> t.do_test(np.array([11,5,8,11,8,7]),np.array([1/6,1/6,1/6,1/6,1/6,1/6]))

	"""

	def __init__(self):
		self.n_samples = 1000  # Number of Monte Carlo samples to generate
		self.statistics = np.zeros(1)  # The statistic of each MC sample
		self.fix = False  # Fix the MC sampling, samples will be reused on next runs

	# Generate Monte Carlo samples and calculate likelihood
	def _mc_runs(self, n_obs: int, probs: npt.NDArray[np.float_]) -> None:
		# Generate samples from hypothesised distribution
		m = multinomial.rvs(n=n_obs, p=probs, size=self.n_samples)
		# Calculate the probability of each sample
		self.statistics = np.array(
			[multinomial.pmf(mi, n=n_obs, p=probs) for mi in m])

	# Test whether x was drawn from the hypothesised distribution probs
	def do_test(self,
		x: npt.NDArray[np.int_], probs: npt.NDArray[np.float_]) -> float:

		# Error checking:
		if x.size != probs.size:
			raise ValueError('Input arrays must have the same number of elements')

		# Total number of observations in x
		n_obs = int(np.sum(x))

		# Run MC sampling if not fixed
		if not self.fix:
			self._mc_runs(n_obs, probs)

		# Calculate probability of x under the hypothesised distribution
		x_stat: float = multinomial.pmf(x, n=n_obs, p=probs)

		# Count number of trials with probability smaller than x
		n_smaller = 0
		for s in self.statistics:
			if s <= x_stat:
				n_smaller += 1

		# The p-value is the fraction of samples with smaller probability than x
		return n_smaller / self.statistics.size
