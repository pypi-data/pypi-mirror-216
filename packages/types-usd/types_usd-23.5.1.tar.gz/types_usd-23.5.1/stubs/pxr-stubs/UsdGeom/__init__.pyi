# mypy: disable_error_code = misc
import Boost.Python
import pxr.Tf
import typing
from typing import Any, ClassVar, overload

class BBoxCache(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    def __init__(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode, includedPurposes: object, useExtentsHint: bool = ..., ignoreVisibility: bool = ...) -> None: ...
    def Clear(self) -> None: ...
    def ClearBaseTime(self) -> None: ...
    def ComputeLocalBound(self, prim: pxr.Usd.Prim) -> pxr.Gf.BBox3d: ...
    def ComputePointInstanceLocalBound(self, instancer: PointInstancer, instanceId: int) -> pxr.Gf.BBox3d: ...
    def ComputePointInstanceLocalBounds(self, instancer: PointInstancer, instanceIds: int) -> tuple[int64_t, pxr.Gf.BBox3d]: ...
    def ComputePointInstanceRelativeBound(self, instancer: PointInstancer, instanceId: int, relativeToAncestorPrim: pxr.Usd.Prim) -> pxr.Gf.BBox3d: ...
    def ComputePointInstanceRelativeBounds(self, instancer: PointInstancer, instanceIds: int, relativeToAncestorPrim: pxr.Usd.Prim) -> tuple[int64_t, pxr.Gf.BBox3d]: ...
    def ComputePointInstanceUntransformedBound(self, instancer: PointInstancer, instanceId: int) -> pxr.Gf.BBox3d: ...
    def ComputePointInstanceUntransformedBounds(self, instancer: PointInstancer, instanceIds: int) -> tuple[int64_t, pxr.Gf.BBox3d]: ...
    def ComputePointInstanceWorldBound(self, instancer: PointInstancer, instanceId: int) -> pxr.Gf.BBox3d: ...
    def ComputePointInstanceWorldBounds(self, instancer: PointInstancer, instanceIds: int) -> tuple[int64_t, pxr.Gf.BBox3d]: ...
    def ComputeRelativeBound(self, prim: pxr.Usd.Prim, relativeRootPrim: pxr.Usd.Prim) -> pxr.Gf.BBox3d: ...
    @overload
    def ComputeUntransformedBound(self, prim: pxr.Usd.Prim, pathsToSkip: typing.Iterable[pxr.Sdf.Path | str], ctmOverrides: pxr.Tf.HashMap[pxr.Sdf.Path | str, pxr.Gf.Matrix4d, pxr.Sdf.Path.Hash]) -> pxr.Gf.BBox3d: ...
    @overload
    def ComputeUntransformedBound(self, prim: pxr.Usd.Prim) -> pxr.Gf.BBox3d: ...
    def ComputeWorldBound(self, prim: pxr.Usd.Prim) -> pxr.Gf.BBox3d: ...
    def ComputeWorldBoundWithOverrides(self, prim: pxr.Usd.Prim, pathsToSkip: typing.Iterable[pxr.Sdf.Path | str], primOverride: pxr.Gf.Matrix4d, ctmOverrides: pxr.Tf.HashMap[pxr.Sdf.Path | str, pxr.Gf.Matrix4d, pxr.Sdf.Path.Hash]) -> pxr.Gf.BBox3d: ...
    def GetBaseTime(self) -> pxr.Usd.TimeCode: ...
    def GetIncludedPurposes(self) -> list[str]: ...
    def GetTime(self) -> pxr.Usd.TimeCode: ...
    def GetUseExtentsHint(self) -> bool: ...
    def HasBaseTime(self) -> bool: ...
    def SetBaseTime(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> None: ...
    def SetIncludedPurposes(self, includedPurposes: list[str] | list[pxr.Ar.ResolvedPath]) -> None: ...
    def SetTime(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> None: ...
    def __reduce__(self) -> Any: ...

class BasisCurves(Curves):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def ComputeInterpolationForSize(self, arg2: int, arg3: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> tuple[str, ComputeInterpolationInfo]: ...
    def ComputeUniformDataSize(self, arg2: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> int: ...
    def ComputeVaryingDataSize(self, arg2: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> int: ...
    def ComputeVertexDataSize(self, arg2: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> int: ...
    def CreateBasisAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateTypeAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateWrapAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def Define(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> BasisCurves: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> BasisCurves: ...
    def GetBasisAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    def GetTypeAttr(self) -> pxr.Usd.Attribute: ...
    def GetWrapAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class Boundable(Xformable):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def ComputeExtent(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> pxr.Vt.Vec3fArray: ...
    @overload
    @classmethod
    def ComputeExtentFromPlugins(cls, boundable: Boundable, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode, transform: pxr.Gf.Matrix4d) -> pxr.Vt.Vec3fArray: ...
    @overload
    @classmethod
    def ComputeExtentFromPlugins(cls, boundable: Boundable, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> pxr.Vt.Vec3fArray: ...
    def CreateExtentAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Boundable: ...
    def GetExtentAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class Camera(Xformable):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def CreateClippingPlanesAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateClippingRangeAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateExposureAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateFStopAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateFocalLengthAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateFocusDistanceAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateHorizontalApertureAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateHorizontalApertureOffsetAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateProjectionAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateShutterCloseAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateShutterOpenAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateStereoRoleAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateVerticalApertureAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateVerticalApertureOffsetAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def Define(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Camera: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Camera: ...
    def GetCamera(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> pxr.Gf.Camera: ...
    def GetClippingPlanesAttr(self) -> pxr.Usd.Attribute: ...
    def GetClippingRangeAttr(self) -> pxr.Usd.Attribute: ...
    def GetExposureAttr(self) -> pxr.Usd.Attribute: ...
    def GetFStopAttr(self) -> pxr.Usd.Attribute: ...
    def GetFocalLengthAttr(self) -> pxr.Usd.Attribute: ...
    def GetFocusDistanceAttr(self) -> pxr.Usd.Attribute: ...
    def GetHorizontalApertureAttr(self) -> pxr.Usd.Attribute: ...
    def GetHorizontalApertureOffsetAttr(self) -> pxr.Usd.Attribute: ...
    def GetProjectionAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    def GetShutterCloseAttr(self) -> pxr.Usd.Attribute: ...
    def GetShutterOpenAttr(self) -> pxr.Usd.Attribute: ...
    def GetStereoRoleAttr(self) -> pxr.Usd.Attribute: ...
    def GetVerticalApertureAttr(self) -> pxr.Usd.Attribute: ...
    def GetVerticalApertureOffsetAttr(self) -> pxr.Usd.Attribute: ...
    def SetFromCamera(self, camera: pxr.Gf.Camera, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> None: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class Capsule(Gprim):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def CreateAxisAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateExtentAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateHeightAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateRadiusAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def Define(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Capsule: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Capsule: ...
    def GetAxisAttr(self) -> pxr.Usd.Attribute: ...
    def GetExtentAttr(self) -> pxr.Usd.Attribute: ...
    def GetHeightAttr(self) -> pxr.Usd.Attribute: ...
    def GetRadiusAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class Cone(Gprim):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def CreateAxisAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateExtentAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateHeightAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateRadiusAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def Define(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Cone: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Cone: ...
    def GetAxisAttr(self) -> pxr.Usd.Attribute: ...
    def GetExtentAttr(self) -> pxr.Usd.Attribute: ...
    def GetHeightAttr(self) -> pxr.Usd.Attribute: ...
    def GetRadiusAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class ConstraintTarget(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, attr: pxr.Usd.Attribute | ConstraintTarget | Primvar | XformOp | pxr.UsdShade.Input | pxr.UsdShade.Output) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def ComputeInWorldSpace(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> pxr.Gf.Matrix4d: ...
    def Get(self, arg2: pxr.Gf.Matrix4d, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> bool: ...
    def GetAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def GetConstraintAttrName(cls, arg1: str | pxr.Ar.ResolvedPath) -> str: ...
    def GetIdentifier(self) -> str: ...
    def IsDefined(self) -> bool: ...
    @classmethod
    def IsValid(cls, arg1: pxr.Usd.Attribute | ConstraintTarget | Primvar | XformOp | pxr.UsdShade.Input | pxr.UsdShade.Output) -> bool: ...
    def Set(self, value: pxr.Gf.Matrix4d, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> bool: ...
    def SetIdentifier(self, identifier: str | pxr.Ar.ResolvedPath) -> None: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class Cube(Gprim):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def CreateExtentAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateSizeAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def Define(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Cube: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Cube: ...
    def GetExtentAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    def GetSizeAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class Curves(PointBased):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @classmethod
    def ComputeExtent(cls, points: object, widths: object) -> Any: ...
    def CreateCurveVertexCountsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateWidthsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Curves: ...
    def GetCurveCount(self, timeCode: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> int: ...
    def GetCurveVertexCountsAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    def GetWidthsAttr(self) -> pxr.Usd.Attribute: ...
    def GetWidthsInterpolation(self) -> str: ...
    def SetWidthsInterpolation(self, interpolation: str | pxr.Ar.ResolvedPath) -> bool: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class Cylinder(Gprim):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def CreateAxisAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateExtentAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateHeightAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateRadiusAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def Define(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Cylinder: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Cylinder: ...
    def GetAxisAttr(self) -> pxr.Usd.Attribute: ...
    def GetExtentAttr(self) -> pxr.Usd.Attribute: ...
    def GetHeightAttr(self) -> pxr.Usd.Attribute: ...
    def GetRadiusAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class Gprim(Boundable):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def CreateDisplayColorAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateDisplayColorPrimvar(self, interpolation: str | pxr.Ar.ResolvedPath = ..., elementSize: int = ...) -> Primvar: ...
    def CreateDisplayOpacityAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateDisplayOpacityPrimvar(self, interpolation: str | pxr.Ar.ResolvedPath = ..., elementSize: int = ...) -> Primvar: ...
    def CreateDoubleSidedAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateOrientationAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Gprim: ...
    def GetDisplayColorAttr(self) -> pxr.Usd.Attribute: ...
    def GetDisplayColorPrimvar(self) -> Primvar: ...
    def GetDisplayOpacityAttr(self) -> pxr.Usd.Attribute: ...
    def GetDisplayOpacityPrimvar(self) -> Primvar: ...
    def GetDoubleSidedAttr(self) -> pxr.Usd.Attribute: ...
    def GetOrientationAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class HermiteCurves(Curves):
    class PointAndTangentArrays(Boost.Python.instance):
        __instance_size__: ClassVar[int] = ...
        @overload
        def __init__(self, arg2: pxr.Vt.Vec3fArray | typing.Iterable[pxr.Gf.Vec3f], arg3: pxr.Vt.Vec3fArray | typing.Iterable[pxr.Gf.Vec3f]) -> None: ...
        @overload
        def __init__(self) -> None: ...
        def GetPoints(self) -> pxr.Vt.Vec3fArray: ...
        def GetTangents(self) -> pxr.Vt.Vec3fArray: ...
        def Interleave(self) -> pxr.Vt.Vec3fArray: ...
        def IsEmpty(self) -> bool: ...
        def Separate(self, arg1: pxr.Vt.Vec3fArray | typing.Iterable[pxr.Gf.Vec3f]) -> HermiteCurves.PointAndTangentArrays: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __reduce__(self) -> Any: ...
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def CreateTangentsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def Define(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> HermiteCurves: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> HermiteCurves: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    def GetTangentsAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class Imageable(pxr.Usd.Typed):
    class PurposeInfo(Boost.Python.instance):
        __instance_size__: ClassVar[int] = ...
        isInheritable: Any
        purpose: Any
        @overload
        def __init__(self, arg2: object, arg3: bool) -> None: ...
        @overload
        def __init__(self) -> None: ...
        def GetInheritablePurpose(self) -> Any: ...
        def __bool__(self) -> bool: ...
        def __eq__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __reduce__(self) -> Any: ...
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def ComputeEffectiveVisibility(self, purpose: str | pxr.Ar.ResolvedPath = ..., time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> str: ...
    def ComputeLocalBound(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode, purpose1: str | pxr.Ar.ResolvedPath = ..., purpose2: str | pxr.Ar.ResolvedPath = ..., purpose3: str | pxr.Ar.ResolvedPath = ..., purpose4: str | pxr.Ar.ResolvedPath = ...) -> pxr.Gf.BBox3d: ...
    def ComputeLocalToWorldTransform(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> pxr.Gf.Matrix4d: ...
    def ComputeParentToWorldTransform(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> pxr.Gf.Matrix4d: ...
    def ComputeProxyPrim(self) -> tuple[pxr.Usd.Prim, pxr.Usd.Prim]: ...
    def ComputePurpose(self) -> str: ...
    @overload
    def ComputePurposeInfo(self, parentPurposeInfo: Imageable.PurposeInfo) -> Imageable.PurposeInfo: ...
    @overload
    def ComputePurposeInfo(self) -> Imageable.PurposeInfo: ...
    def ComputeUntransformedBound(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode, purpose1: str | pxr.Ar.ResolvedPath = ..., purpose2: str | pxr.Ar.ResolvedPath = ..., purpose3: str | pxr.Ar.ResolvedPath = ..., purpose4: str | pxr.Ar.ResolvedPath = ...) -> pxr.Gf.BBox3d: ...
    def ComputeVisibility(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> str: ...
    def ComputeWorldBound(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode, purpose1: str | pxr.Ar.ResolvedPath = ..., purpose2: str | pxr.Ar.ResolvedPath = ..., purpose3: str | pxr.Ar.ResolvedPath = ..., purpose4: str | pxr.Ar.ResolvedPath = ...) -> pxr.Gf.BBox3d: ...
    def CreateProxyPrimRel(self) -> pxr.Usd.Relationship: ...
    def CreatePurposeAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateVisibilityAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Imageable: ...
    @classmethod
    def GetOrderedPurposeTokens(cls) -> list[str]: ...
    def GetProxyPrimRel(self) -> pxr.Usd.Relationship: ...
    def GetPurposeAttr(self) -> pxr.Usd.Attribute: ...
    def GetPurposeVisibilityAttr(self, purpose: str | pxr.Ar.ResolvedPath = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    def GetVisibilityAttr(self) -> pxr.Usd.Attribute: ...
    def MakeInvisible(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> None: ...
    def MakeVisible(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> None: ...
    @overload
    def SetProxyPrim(self, proxy: pxr.Usd.Prim) -> bool: ...
    @overload
    def SetProxyPrim(self, proxy: pxr.Usd.SchemaBase) -> bool: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class LinearUnits(Boost.Python.instance):
    centimeters: ClassVar[Any] = ...  # read-only
    feet: ClassVar[Any] = ...  # read-only
    inches: ClassVar[Any] = ...  # read-only
    kilometers: ClassVar[Any] = ...  # read-only
    lightYears: ClassVar[Any] = ...  # read-only
    meters: ClassVar[Any] = ...  # read-only
    micrometers: ClassVar[Any] = ...  # read-only
    miles: ClassVar[Any] = ...  # read-only
    millimeters: ClassVar[Any] = ...  # read-only
    nanometers: ClassVar[Any] = ...  # read-only
    yards: ClassVar[Any] = ...  # read-only
    def __init__(self, *args, **kwargs) -> None: ...
    def __reduce__(self) -> Any: ...

class Mesh(PointBased):
    SHARPNESS_INFINITE: ClassVar[float] = ...
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def CreateCornerIndicesAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateCornerSharpnessesAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateCreaseIndicesAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateCreaseLengthsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateCreaseSharpnessesAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateFaceVaryingLinearInterpolationAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateFaceVertexCountsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateFaceVertexIndicesAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateHoleIndicesAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateInterpolateBoundaryAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateSubdivisionSchemeAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateTriangleSubdivisionRuleAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def Define(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Mesh: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Mesh: ...
    def GetCornerIndicesAttr(self) -> pxr.Usd.Attribute: ...
    def GetCornerSharpnessesAttr(self) -> pxr.Usd.Attribute: ...
    def GetCreaseIndicesAttr(self) -> pxr.Usd.Attribute: ...
    def GetCreaseLengthsAttr(self) -> pxr.Usd.Attribute: ...
    def GetCreaseSharpnessesAttr(self) -> pxr.Usd.Attribute: ...
    def GetFaceCount(self, timeCode: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> int: ...
    def GetFaceVaryingLinearInterpolationAttr(self) -> pxr.Usd.Attribute: ...
    def GetFaceVertexCountsAttr(self) -> pxr.Usd.Attribute: ...
    def GetFaceVertexIndicesAttr(self) -> pxr.Usd.Attribute: ...
    def GetHoleIndicesAttr(self) -> pxr.Usd.Attribute: ...
    def GetInterpolateBoundaryAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    def GetSubdivisionSchemeAttr(self) -> pxr.Usd.Attribute: ...
    def GetTriangleSubdivisionRuleAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def ValidateTopology(cls, faceVertexIndices: pxr.Vt.IntArray | typing.Iterable[int], faceVertexCounts: pxr.Vt.IntArray | typing.Iterable[int], numPoints: int) -> tuple: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class ModelAPI(pxr.Usd.APISchemaBase):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @classmethod
    def Apply(cls, prim: pxr.Usd.Prim) -> ModelAPI: ...
    @classmethod
    def CanApply(cls, prim: pxr.Usd.Prim) -> _CanApplyResult: ...
    def ComputeExtentsHint(self, bboxCache: BBoxCache) -> pxr.Vt.Vec3fArray: ...
    def ComputeModelDrawMode(self, parentDrawMode: str | pxr.Ar.ResolvedPath = ...) -> str: ...
    def CreateConstraintTarget(self, arg2: str | pxr.Ar.ResolvedPath) -> ConstraintTarget: ...
    def CreateModelApplyDrawModeAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateModelCardGeometryAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateModelCardTextureXNegAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateModelCardTextureXPosAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateModelCardTextureYNegAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateModelCardTextureYPosAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateModelCardTextureZNegAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateModelCardTextureZPosAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateModelDrawModeAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateModelDrawModeColorAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> ModelAPI: ...
    def GetConstraintTarget(self, arg2: str | pxr.Ar.ResolvedPath) -> ConstraintTarget: ...
    def GetConstraintTargets(self) -> list[ConstraintTarget]: ...
    def GetExtentsHint(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> pxr.Vt.Vec3fArray: ...
    def GetExtentsHintAttr(self) -> pxr.Usd.Attribute: ...
    def GetModelApplyDrawModeAttr(self) -> pxr.Usd.Attribute: ...
    def GetModelCardGeometryAttr(self) -> pxr.Usd.Attribute: ...
    def GetModelCardTextureXNegAttr(self) -> pxr.Usd.Attribute: ...
    def GetModelCardTextureXPosAttr(self) -> pxr.Usd.Attribute: ...
    def GetModelCardTextureYNegAttr(self) -> pxr.Usd.Attribute: ...
    def GetModelCardTextureYPosAttr(self) -> pxr.Usd.Attribute: ...
    def GetModelCardTextureZNegAttr(self) -> pxr.Usd.Attribute: ...
    def GetModelCardTextureZPosAttr(self) -> pxr.Usd.Attribute: ...
    def GetModelDrawModeAttr(self) -> pxr.Usd.Attribute: ...
    def GetModelDrawModeColorAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    def SetExtentsHint(self, extents: pxr.Vt.Vec3fArray | typing.Iterable[pxr.Gf.Vec3f], time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> bool: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class MotionAPI(pxr.Usd.APISchemaBase):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @classmethod
    def Apply(cls, prim: pxr.Usd.Prim) -> MotionAPI: ...
    @classmethod
    def CanApply(cls, prim: pxr.Usd.Prim) -> _CanApplyResult: ...
    def ComputeMotionBlurScale(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> float: ...
    def ComputeNonlinearSampleCount(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> int: ...
    def ComputeVelocityScale(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> float: ...
    def CreateMotionBlurScaleAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateNonlinearSampleCountAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateVelocityScaleAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> MotionAPI: ...
    def GetMotionBlurScaleAttr(self) -> pxr.Usd.Attribute: ...
    def GetNonlinearSampleCountAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    def GetVelocityScaleAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class NurbsCurves(Curves):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def CreateKnotsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateOrderAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreatePointWeightsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateRangesAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def Define(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> NurbsCurves: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> NurbsCurves: ...
    def GetKnotsAttr(self) -> pxr.Usd.Attribute: ...
    def GetOrderAttr(self) -> pxr.Usd.Attribute: ...
    def GetPointWeightsAttr(self) -> pxr.Usd.Attribute: ...
    def GetRangesAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class NurbsPatch(PointBased):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def CreatePointWeightsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateTrimCurveCountsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateTrimCurveKnotsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateTrimCurveOrdersAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateTrimCurvePointsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateTrimCurveRangesAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateTrimCurveVertexCountsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateUFormAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateUKnotsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateUOrderAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateURangeAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateUVertexCountAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateVFormAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateVKnotsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateVOrderAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateVRangeAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateVVertexCountAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def Define(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> NurbsPatch: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> NurbsPatch: ...
    def GetPointWeightsAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    def GetTrimCurveCountsAttr(self) -> pxr.Usd.Attribute: ...
    def GetTrimCurveKnotsAttr(self) -> pxr.Usd.Attribute: ...
    def GetTrimCurveOrdersAttr(self) -> pxr.Usd.Attribute: ...
    def GetTrimCurvePointsAttr(self) -> pxr.Usd.Attribute: ...
    def GetTrimCurveRangesAttr(self) -> pxr.Usd.Attribute: ...
    def GetTrimCurveVertexCountsAttr(self) -> pxr.Usd.Attribute: ...
    def GetUFormAttr(self) -> pxr.Usd.Attribute: ...
    def GetUKnotsAttr(self) -> pxr.Usd.Attribute: ...
    def GetUOrderAttr(self) -> pxr.Usd.Attribute: ...
    def GetURangeAttr(self) -> pxr.Usd.Attribute: ...
    def GetUVertexCountAttr(self) -> pxr.Usd.Attribute: ...
    def GetVFormAttr(self) -> pxr.Usd.Attribute: ...
    def GetVKnotsAttr(self) -> pxr.Usd.Attribute: ...
    def GetVOrderAttr(self) -> pxr.Usd.Attribute: ...
    def GetVRangeAttr(self) -> pxr.Usd.Attribute: ...
    def GetVVertexCountAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class Plane(Gprim):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def CreateAxisAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateDoubleSidedAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateExtentAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateLengthAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateWidthAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def Define(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Plane: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Plane: ...
    def GetAxisAttr(self) -> pxr.Usd.Attribute: ...
    def GetDoubleSidedAttr(self) -> pxr.Usd.Attribute: ...
    def GetExtentAttr(self) -> pxr.Usd.Attribute: ...
    def GetLengthAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    def GetWidthAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class PointBased(Gprim):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @classmethod
    def ComputeExtent(cls, points: object) -> Any: ...
    @classmethod
    def ComputePointsAtTime(cls, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode, baseTime: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> pxr.Vt.Vec3fArray: ...
    def ComputePointsAtTimes(self, times: typing.Iterable[pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode], baseTime: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> list[pxr.Vt.Array[pxr.Gf.Vec3f]]: ...
    def CreateAccelerationsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateNormalsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreatePointsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateVelocitiesAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> PointBased: ...
    def GetAccelerationsAttr(self) -> pxr.Usd.Attribute: ...
    def GetNormalsAttr(self) -> pxr.Usd.Attribute: ...
    def GetNormalsInterpolation(self) -> str: ...
    def GetPointsAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    def GetVelocitiesAttr(self) -> pxr.Usd.Attribute: ...
    def SetNormalsInterpolation(self, interpolation: str | pxr.Ar.ResolvedPath) -> bool: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class PointInstancer(Boundable):
    class MaskApplication(pxr.Tf.Tf_PyEnumWrapper):
        _baseName: ClassVar[str] = ...
        allValues: ClassVar[tuple] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        def GetValueFromName(self, name: object) -> Any: ...
        def __reduce__(self) -> Any: ...
    class ProtoXformInclusion(pxr.Tf.Tf_PyEnumWrapper):
        _baseName: ClassVar[str] = ...
        allValues: ClassVar[tuple] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        def GetValueFromName(self, name: object) -> Any: ...
        def __reduce__(self) -> Any: ...
    ApplyMask: ClassVar[PointInstancer.MaskApplication] = ...
    ExcludeProtoXform: ClassVar[PointInstancer.ProtoXformInclusion] = ...
    IgnoreMask: ClassVar[PointInstancer.MaskApplication] = ...
    IncludeProtoXform: ClassVar[PointInstancer.ProtoXformInclusion] = ...
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def ActivateAllIds(self) -> bool: ...
    def ActivateId(self, id: int) -> bool: ...
    def ActivateIds(self, ids: pxr.Vt.Int64Array | typing.Iterable[int]) -> bool: ...
    def ComputeExtentAtTime(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode, baseTime: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> pxr.Vt.Vec3fArray: ...
    def ComputeExtentAtTimes(self, times: object, baseTime: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> Any: ...
    @classmethod
    def ComputeInstanceTransformsAtTime(cls, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode, baseTime: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode, doProtoXforms: object = ..., applyMask: object = ...) -> pxr.Vt.Matrix4dArray: ...
    def ComputeInstanceTransformsAtTimes(self, times: typing.Iterable[pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode], baseTime: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode, doProtoXforms: PointInstancer.ProtoXformInclusion = ..., applyMask: PointInstancer.MaskApplication = ...) -> list[pxr.Vt.Array[pxr.Gf.Matrix4d]]: ...
    def ComputeMaskAtTime(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> list: ...
    def CreateAccelerationsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateAngularVelocitiesAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateIdsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateInvisibleIdsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateOrientationsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreatePositionsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateProtoIndicesAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreatePrototypesRel(self) -> pxr.Usd.Relationship: ...
    def CreateScalesAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateVelocitiesAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def DeactivateId(self, id: int) -> bool: ...
    def DeactivateIds(self, ids: pxr.Vt.Int64Array | typing.Iterable[int]) -> bool: ...
    @classmethod
    def Define(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> PointInstancer: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> PointInstancer: ...
    def GetAccelerationsAttr(self) -> pxr.Usd.Attribute: ...
    def GetAngularVelocitiesAttr(self) -> pxr.Usd.Attribute: ...
    def GetIdsAttr(self) -> pxr.Usd.Attribute: ...
    def GetInstanceCount(self, timeCode: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> int: ...
    def GetInvisibleIdsAttr(self) -> pxr.Usd.Attribute: ...
    def GetOrientationsAttr(self) -> pxr.Usd.Attribute: ...
    def GetPositionsAttr(self) -> pxr.Usd.Attribute: ...
    def GetProtoIndicesAttr(self) -> pxr.Usd.Attribute: ...
    def GetPrototypesRel(self) -> pxr.Usd.Relationship: ...
    def GetScalesAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    def GetVelocitiesAttr(self) -> pxr.Usd.Attribute: ...
    def InvisId(self, id: int, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> bool: ...
    def InvisIds(self, ids: pxr.Vt.Int64Array | typing.Iterable[int], time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> bool: ...
    def VisAllIds(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> bool: ...
    def VisId(self, id: int, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> bool: ...
    def VisIds(self, ids: pxr.Vt.Int64Array | typing.Iterable[int], time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> bool: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class Points(PointBased):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @classmethod
    def ComputeExtent(cls, points: object, widths: object) -> Any: ...
    def CreateIdsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateWidthsAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def Define(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Points: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Points: ...
    def GetIdsAttr(self) -> pxr.Usd.Attribute: ...
    def GetPointCount(self, timeCode: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> int: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    def GetWidthsAttr(self) -> pxr.Usd.Attribute: ...
    def GetWidthsInterpolation(self) -> str: ...
    def SetWidthsInterpolation(self, interpolation: str | pxr.Ar.ResolvedPath) -> bool: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class Primvar(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, attr: pxr.Usd.Attribute | ConstraintTarget | Primvar | XformOp | pxr.UsdShade.Input | pxr.UsdShade.Output) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def BlockIndices(self) -> None: ...
    @classmethod
    def ComputeFlattened(cls, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> Any: ...
    def CreateIndicesAttr(self) -> pxr.Usd.Attribute: ...
    def Get(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> Any: ...
    def GetAttr(self) -> pxr.Usd.Attribute: ...
    def GetBaseName(self) -> str: ...
    def GetDeclarationInfo(self) -> tuple: ...
    def GetElementSize(self) -> int: ...
    def GetIndices(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> pxr.Vt.IntArray: ...
    def GetIndicesAttr(self) -> pxr.Usd.Attribute: ...
    def GetInterpolation(self) -> str: ...
    def GetName(self) -> str: ...
    def GetNamespace(self) -> str: ...
    def GetPrimvarName(self) -> str: ...
    def GetTimeSamples(self) -> list[float]: ...
    def GetTimeSamplesInInterval(self, arg2: pxr.Gf.Interval) -> list[float]: ...
    def GetTypeName(self) -> pxr.Sdf.ValueTypeName: ...
    def GetUnauthoredValuesIndex(self) -> int: ...
    def HasAuthoredElementSize(self) -> bool: ...
    def HasAuthoredInterpolation(self) -> bool: ...
    def HasAuthoredValue(self) -> bool: ...
    def HasValue(self) -> bool: ...
    def IsDefined(self) -> bool: ...
    def IsIdTarget(self) -> bool: ...
    def IsIndexed(self) -> bool: ...
    @classmethod
    def IsPrimvar(cls, attr: pxr.Usd.Attribute | ConstraintTarget | Primvar | XformOp | pxr.UsdShade.Input | pxr.UsdShade.Output) -> bool: ...
    @classmethod
    def IsValidInterpolation(cls, interpolation: str | pxr.Ar.ResolvedPath) -> bool: ...
    @classmethod
    def IsValidPrimvarName(cls, name: str | pxr.Ar.ResolvedPath) -> bool: ...
    def NameContainsNamespaces(self) -> bool: ...
    def Set(self, value: T, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> bool: ...
    def SetElementSize(self, eltSize: int) -> bool: ...
    def SetIdTarget(self, arg2: pxr.Sdf.Path | str) -> bool: ...
    def SetIndices(self, indices: pxr.Vt.IntArray | typing.Iterable[int], time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> bool: ...
    def SetInterpolation(self, interpolation: str | pxr.Ar.ResolvedPath) -> bool: ...
    def SetUnauthoredValuesIndex(self, unauthoredValuesIndex: int) -> bool: ...
    def SplitName(self) -> list[str]: ...
    @classmethod
    def StripPrimvarsName(cls, name: str | pxr.Ar.ResolvedPath) -> str: ...
    def ValueMightBeTimeVarying(self) -> bool: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __reduce__(self) -> Any: ...

class PrimvarsAPI(pxr.Usd.APISchemaBase):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def BlockPrimvar(self, name: str | pxr.Ar.ResolvedPath) -> None: ...
    @classmethod
    def CanContainPropertyName(cls, name: str | pxr.Ar.ResolvedPath) -> bool: ...
    def CreateIndexedPrimvar(self, name: str | pxr.Ar.ResolvedPath, typeName: pxr.Sdf.ValueTypeName, value: T, indices: pxr.Vt.IntArray | typing.Iterable[int], interpolation: str | pxr.Ar.ResolvedPath = ..., elementSize: int = ..., time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> Primvar: ...
    def CreateNonIndexedPrimvar(self, name: str | pxr.Ar.ResolvedPath, typeName: pxr.Sdf.ValueTypeName, value: T, interpolation: str | pxr.Ar.ResolvedPath = ..., elementSize: int = ..., time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> Primvar: ...
    def CreatePrimvar(self, name: str | pxr.Ar.ResolvedPath, typeName: pxr.Sdf.ValueTypeName, interpolation: str | pxr.Ar.ResolvedPath = ..., elementSize: int = ...) -> Primvar: ...
    def FindIncrementallyInheritablePrimvars(self, inheritedFromAncestors: typing.Iterable[Primvar]) -> list[Primvar]: ...
    def FindInheritablePrimvars(self) -> list[Primvar]: ...
    @overload
    def FindPrimvarWithInheritance(self, name: str | pxr.Ar.ResolvedPath, inheritedFromAncestors: typing.Iterable[Primvar]) -> Primvar: ...
    @overload
    def FindPrimvarWithInheritance(self, name: str | pxr.Ar.ResolvedPath) -> Primvar: ...
    @overload
    def FindPrimvarsWithInheritance(self, inheritedFromAncestors: typing.Iterable[Primvar]) -> list[Primvar]: ...
    @overload
    def FindPrimvarsWithInheritance(self) -> list[Primvar]: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> PrimvarsAPI: ...
    def GetAuthoredPrimvars(self) -> list[Primvar]: ...
    def GetPrimvar(self, name: str | pxr.Ar.ResolvedPath) -> Primvar: ...
    def GetPrimvars(self) -> list[Primvar]: ...
    def GetPrimvarsWithAuthoredValues(self) -> list[Primvar]: ...
    def GetPrimvarsWithValues(self) -> list[Primvar]: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    def HasPossiblyInheritedPrimvar(self, name: str | pxr.Ar.ResolvedPath) -> bool: ...
    def HasPrimvar(self, name: str | pxr.Ar.ResolvedPath) -> bool: ...
    def RemovePrimvar(self, name: str | pxr.Ar.ResolvedPath) -> bool: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class Scope(Imageable):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @classmethod
    def Define(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Scope: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Scope: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class Sphere(Gprim):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def CreateExtentAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateRadiusAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def Define(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Sphere: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Sphere: ...
    def GetExtentAttr(self) -> pxr.Usd.Attribute: ...
    def GetRadiusAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class Subset(pxr.Usd.Typed):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def CreateElementTypeAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateFamilyNameAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def CreateGeomSubset(cls, geom: Imageable, subsetName: str | pxr.Ar.ResolvedPath, elementType: str | pxr.Ar.ResolvedPath, indices: pxr.Vt.IntArray | typing.Iterable[int], familyName: str | pxr.Ar.ResolvedPath = ..., familyType: str | pxr.Ar.ResolvedPath = ...) -> Subset: ...
    def CreateIndicesAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def CreateUniqueGeomSubset(cls, geom: Imageable, subsetName: str | pxr.Ar.ResolvedPath, elementType: str | pxr.Ar.ResolvedPath, indices: pxr.Vt.IntArray | typing.Iterable[int], familyName: str | pxr.Ar.ResolvedPath = ..., familyType: str | pxr.Ar.ResolvedPath = ...) -> Subset: ...
    @classmethod
    def Define(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Subset: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Subset: ...
    @classmethod
    def GetAllGeomSubsetFamilyNames(cls, geom: Imageable) -> list: ...
    @classmethod
    def GetAllGeomSubsets(cls, geom: Imageable) -> list[Subset]: ...
    def GetElementTypeAttr(self) -> pxr.Usd.Attribute: ...
    def GetFamilyNameAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def GetFamilyType(cls, geom: Imageable, familyName: str | pxr.Ar.ResolvedPath) -> str: ...
    @classmethod
    def GetGeomSubsets(cls, geom: Imageable, elementType: str | pxr.Ar.ResolvedPath = ..., familyName: str | pxr.Ar.ResolvedPath = ...) -> list[Subset]: ...
    def GetIndicesAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    @classmethod
    def GetUnassignedIndices(cls, subsets: typing.Iterable[Subset], elementCount: int, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> pxr.Vt.IntArray: ...
    @classmethod
    def SetFamilyType(cls, geom: Imageable, familyName: str | pxr.Ar.ResolvedPath, familyType: str | pxr.Ar.ResolvedPath) -> bool: ...
    @classmethod
    def ValidateFamily(cls, geom: Imageable, elementType: str | pxr.Ar.ResolvedPath = ..., familyName: str | pxr.Ar.ResolvedPath = ...) -> str: ...
    @classmethod
    def ValidateSubsets(cls, subsets: typing.Iterable[Subset], elementCount: int, familyType: str | pxr.Ar.ResolvedPath) -> str: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class Tokens(Boost.Python.instance):
    BasisCurves: ClassVar[Any] = ...  # read-only
    Boundable: ClassVar[Any] = ...  # read-only
    Camera: ClassVar[Any] = ...  # read-only
    Capsule: ClassVar[Any] = ...  # read-only
    Cone: ClassVar[Any] = ...  # read-only
    Cube: ClassVar[Any] = ...  # read-only
    Curves: ClassVar[Any] = ...  # read-only
    Cylinder: ClassVar[Any] = ...  # read-only
    GeomModelAPI: ClassVar[Any] = ...  # read-only
    GeomSubset: ClassVar[Any] = ...  # read-only
    Gprim: ClassVar[Any] = ...  # read-only
    HermiteCurves: ClassVar[Any] = ...  # read-only
    Imageable: ClassVar[Any] = ...  # read-only
    Mesh: ClassVar[Any] = ...  # read-only
    MotionAPI: ClassVar[Any] = ...  # read-only
    NurbsCurves: ClassVar[Any] = ...  # read-only
    NurbsPatch: ClassVar[Any] = ...  # read-only
    Plane: ClassVar[Any] = ...  # read-only
    PointBased: ClassVar[Any] = ...  # read-only
    PointInstancer: ClassVar[Any] = ...  # read-only
    Points: ClassVar[Any] = ...  # read-only
    PrimvarsAPI: ClassVar[Any] = ...  # read-only
    Scope: ClassVar[Any] = ...  # read-only
    Sphere: ClassVar[Any] = ...  # read-only
    VisibilityAPI: ClassVar[Any] = ...  # read-only
    Xform: ClassVar[Any] = ...  # read-only
    XformCommonAPI: ClassVar[Any] = ...  # read-only
    Xformable: ClassVar[Any] = ...  # read-only
    accelerations: ClassVar[Any] = ...  # read-only
    all: ClassVar[Any] = ...  # read-only
    angularVelocities: ClassVar[Any] = ...  # read-only
    axis: ClassVar[Any] = ...  # read-only
    basis: ClassVar[Any] = ...  # read-only
    bezier: ClassVar[Any] = ...  # read-only
    bilinear: ClassVar[Any] = ...  # read-only
    boundaries: ClassVar[Any] = ...  # read-only
    bounds: ClassVar[Any] = ...  # read-only
    box: ClassVar[Any] = ...  # read-only
    bspline: ClassVar[Any] = ...  # read-only
    cards: ClassVar[Any] = ...  # read-only
    catmullClark: ClassVar[Any] = ...  # read-only
    catmullRom: ClassVar[Any] = ...  # read-only
    clippingPlanes: ClassVar[Any] = ...  # read-only
    clippingRange: ClassVar[Any] = ...  # read-only
    closed: ClassVar[Any] = ...  # read-only
    constant: ClassVar[Any] = ...  # read-only
    cornerIndices: ClassVar[Any] = ...  # read-only
    cornerSharpnesses: ClassVar[Any] = ...  # read-only
    cornersOnly: ClassVar[Any] = ...  # read-only
    cornersPlus1: ClassVar[Any] = ...  # read-only
    cornersPlus2: ClassVar[Any] = ...  # read-only
    creaseIndices: ClassVar[Any] = ...  # read-only
    creaseLengths: ClassVar[Any] = ...  # read-only
    creaseSharpnesses: ClassVar[Any] = ...  # read-only
    cross: ClassVar[Any] = ...  # read-only
    cubic: ClassVar[Any] = ...  # read-only
    curveVertexCounts: ClassVar[Any] = ...  # read-only
    default_: ClassVar[Any] = ...  # read-only
    doubleSided: ClassVar[Any] = ...  # read-only
    edgeAndCorner: ClassVar[Any] = ...  # read-only
    edgeOnly: ClassVar[Any] = ...  # read-only
    elementSize: ClassVar[Any] = ...  # read-only
    elementType: ClassVar[Any] = ...  # read-only
    exposure: ClassVar[Any] = ...  # read-only
    extent: ClassVar[Any] = ...  # read-only
    extentsHint: ClassVar[Any] = ...  # read-only
    fStop: ClassVar[Any] = ...  # read-only
    face: ClassVar[Any] = ...  # read-only
    faceVarying: ClassVar[Any] = ...  # read-only
    faceVaryingLinearInterpolation: ClassVar[Any] = ...  # read-only
    faceVertexCounts: ClassVar[Any] = ...  # read-only
    faceVertexIndices: ClassVar[Any] = ...  # read-only
    familyName: ClassVar[Any] = ...  # read-only
    focalLength: ClassVar[Any] = ...  # read-only
    focusDistance: ClassVar[Any] = ...  # read-only
    fromTexture: ClassVar[Any] = ...  # read-only
    guide: ClassVar[Any] = ...  # read-only
    guideVisibility: ClassVar[Any] = ...  # read-only
    height: ClassVar[Any] = ...  # read-only
    hermite: ClassVar[Any] = ...  # read-only
    holeIndices: ClassVar[Any] = ...  # read-only
    horizontalAperture: ClassVar[Any] = ...  # read-only
    horizontalApertureOffset: ClassVar[Any] = ...  # read-only
    ids: ClassVar[Any] = ...  # read-only
    inactiveIds: ClassVar[Any] = ...  # read-only
    indices: ClassVar[Any] = ...  # read-only
    inherited: ClassVar[Any] = ...  # read-only
    interpolateBoundary: ClassVar[Any] = ...  # read-only
    interpolation: ClassVar[Any] = ...  # read-only
    invisible: ClassVar[Any] = ...  # read-only
    invisibleIds: ClassVar[Any] = ...  # read-only
    knots: ClassVar[Any] = ...  # read-only
    left: ClassVar[Any] = ...  # read-only
    leftHanded: ClassVar[Any] = ...  # read-only
    length: ClassVar[Any] = ...  # read-only
    linear: ClassVar[Any] = ...  # read-only
    loop: ClassVar[Any] = ...  # read-only
    metersPerUnit: ClassVar[Any] = ...  # read-only
    modelApplyDrawMode: ClassVar[Any] = ...  # read-only
    modelCardGeometry: ClassVar[Any] = ...  # read-only
    modelCardTextureXNeg: ClassVar[Any] = ...  # read-only
    modelCardTextureXPos: ClassVar[Any] = ...  # read-only
    modelCardTextureYNeg: ClassVar[Any] = ...  # read-only
    modelCardTextureYPos: ClassVar[Any] = ...  # read-only
    modelCardTextureZNeg: ClassVar[Any] = ...  # read-only
    modelCardTextureZPos: ClassVar[Any] = ...  # read-only
    modelDrawMode: ClassVar[Any] = ...  # read-only
    modelDrawModeColor: ClassVar[Any] = ...  # read-only
    mono: ClassVar[Any] = ...  # read-only
    motionBlurScale: ClassVar[Any] = ...  # read-only
    motionNonlinearSampleCount: ClassVar[Any] = ...  # read-only
    motionVelocityScale: ClassVar[Any] = ...  # read-only
    nonOverlapping: ClassVar[Any] = ...  # read-only
    none: ClassVar[Any] = ...  # read-only
    nonperiodic: ClassVar[Any] = ...  # read-only
    normals: ClassVar[Any] = ...  # read-only
    open: ClassVar[Any] = ...  # read-only
    order: ClassVar[Any] = ...  # read-only
    orientation: ClassVar[Any] = ...  # read-only
    orientations: ClassVar[Any] = ...  # read-only
    origin: ClassVar[Any] = ...  # read-only
    orthographic: ClassVar[Any] = ...  # read-only
    partition: ClassVar[Any] = ...  # read-only
    periodic: ClassVar[Any] = ...  # read-only
    perspective: ClassVar[Any] = ...  # read-only
    pinned: ClassVar[Any] = ...  # read-only
    pivot: ClassVar[Any] = ...  # read-only
    pointWeights: ClassVar[Any] = ...  # read-only
    points: ClassVar[Any] = ...  # read-only
    positions: ClassVar[Any] = ...  # read-only
    power: ClassVar[Any] = ...  # read-only
    primvarsDisplayColor: ClassVar[Any] = ...  # read-only
    primvarsDisplayOpacity: ClassVar[Any] = ...  # read-only
    projection: ClassVar[Any] = ...  # read-only
    protoIndices: ClassVar[Any] = ...  # read-only
    prototypes: ClassVar[Any] = ...  # read-only
    proxy: ClassVar[Any] = ...  # read-only
    proxyPrim: ClassVar[Any] = ...  # read-only
    proxyVisibility: ClassVar[Any] = ...  # read-only
    purpose: ClassVar[Any] = ...  # read-only
    radius: ClassVar[Any] = ...  # read-only
    ranges: ClassVar[Any] = ...  # read-only
    render: ClassVar[Any] = ...  # read-only
    renderVisibility: ClassVar[Any] = ...  # read-only
    right: ClassVar[Any] = ...  # read-only
    rightHanded: ClassVar[Any] = ...  # read-only
    scales: ClassVar[Any] = ...  # read-only
    shutterClose: ClassVar[Any] = ...  # read-only
    shutterOpen: ClassVar[Any] = ...  # read-only
    size: ClassVar[Any] = ...  # read-only
    smooth: ClassVar[Any] = ...  # read-only
    stereoRole: ClassVar[Any] = ...  # read-only
    subdivisionScheme: ClassVar[Any] = ...  # read-only
    tangents: ClassVar[Any] = ...  # read-only
    triangleSubdivisionRule: ClassVar[Any] = ...  # read-only
    trimCurveCounts: ClassVar[Any] = ...  # read-only
    trimCurveKnots: ClassVar[Any] = ...  # read-only
    trimCurveOrders: ClassVar[Any] = ...  # read-only
    trimCurvePoints: ClassVar[Any] = ...  # read-only
    trimCurveRanges: ClassVar[Any] = ...  # read-only
    trimCurveVertexCounts: ClassVar[Any] = ...  # read-only
    type: ClassVar[Any] = ...  # read-only
    uForm: ClassVar[Any] = ...  # read-only
    uKnots: ClassVar[Any] = ...  # read-only
    uOrder: ClassVar[Any] = ...  # read-only
    uRange: ClassVar[Any] = ...  # read-only
    uVertexCount: ClassVar[Any] = ...  # read-only
    unauthoredValuesIndex: ClassVar[Any] = ...  # read-only
    uniform: ClassVar[Any] = ...  # read-only
    unrestricted: ClassVar[Any] = ...  # read-only
    upAxis: ClassVar[Any] = ...  # read-only
    vForm: ClassVar[Any] = ...  # read-only
    vKnots: ClassVar[Any] = ...  # read-only
    vOrder: ClassVar[Any] = ...  # read-only
    vRange: ClassVar[Any] = ...  # read-only
    vVertexCount: ClassVar[Any] = ...  # read-only
    varying: ClassVar[Any] = ...  # read-only
    velocities: ClassVar[Any] = ...  # read-only
    vertex: ClassVar[Any] = ...  # read-only
    verticalAperture: ClassVar[Any] = ...  # read-only
    verticalApertureOffset: ClassVar[Any] = ...  # read-only
    visibility: ClassVar[Any] = ...  # read-only
    visible: ClassVar[Any] = ...  # read-only
    width: ClassVar[Any] = ...  # read-only
    widths: ClassVar[Any] = ...  # read-only
    wrap: ClassVar[Any] = ...  # read-only
    x: ClassVar[Any] = ...  # read-only
    xformOpOrder: ClassVar[Any] = ...  # read-only
    y: ClassVar[Any] = ...  # read-only
    z: ClassVar[Any] = ...  # read-only
    def __init__(self, *args, **kwargs) -> None: ...
    def __reduce__(self) -> Any: ...

class VisibilityAPI(pxr.Usd.APISchemaBase):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @classmethod
    def Apply(cls, prim: pxr.Usd.Prim) -> VisibilityAPI: ...
    @classmethod
    def CanApply(cls, prim: pxr.Usd.Prim) -> _CanApplyResult: ...
    def CreateGuideVisibilityAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateProxyVisibilityAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    def CreateRenderVisibilityAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> VisibilityAPI: ...
    def GetGuideVisibilityAttr(self) -> pxr.Usd.Attribute: ...
    def GetProxyVisibilityAttr(self) -> pxr.Usd.Attribute: ...
    def GetPurposeVisibilityAttr(self, purpose: str | pxr.Ar.ResolvedPath) -> pxr.Usd.Attribute: ...
    def GetRenderVisibilityAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class Xform(Xformable):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @classmethod
    def Define(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Xform: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Xform: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class XformCache(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def Clear(self) -> None: ...
    def ComputeRelativeTransform(self, prim: pxr.Usd.Prim, ancestor: pxr.Usd.Prim) -> tuple: ...
    def GetLocalToWorldTransform(self, prim: pxr.Usd.Prim) -> pxr.Gf.Matrix4d: ...
    def GetLocalTransformation(self, prim: pxr.Usd.Prim) -> tuple: ...
    def GetParentToWorldTransform(self, prim: pxr.Usd.Prim) -> pxr.Gf.Matrix4d: ...
    def GetTime(self) -> pxr.Usd.TimeCode: ...
    def SetTime(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> None: ...
    def Swap(self, other: XformCache) -> None: ...
    def __reduce__(self) -> Any: ...

class XformCommonAPI(pxr.Usd.APISchemaBase):
    class OpFlags(pxr.Tf.Tf_PyEnumWrapper):
        _baseName: ClassVar[str] = ...
        allValues: ClassVar[tuple] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        def GetValueFromName(self, name: object) -> Any: ...
        def __reduce__(self) -> Any: ...
    class RotationOrder(pxr.Tf.Tf_PyEnumWrapper):
        _baseName: ClassVar[str] = ...
        allValues: ClassVar[tuple] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        def GetValueFromName(self, name: object) -> Any: ...
        def __reduce__(self) -> Any: ...
    OpPivot: ClassVar[XformCommonAPI.OpFlags] = ...
    OpRotate: ClassVar[XformCommonAPI.OpFlags] = ...
    OpScale: ClassVar[XformCommonAPI.OpFlags] = ...
    OpTranslate: ClassVar[XformCommonAPI.OpFlags] = ...
    RotationOrderXYZ: ClassVar[XformCommonAPI.RotationOrder] = ...
    RotationOrderXZY: ClassVar[XformCommonAPI.RotationOrder] = ...
    RotationOrderYXZ: ClassVar[XformCommonAPI.RotationOrder] = ...
    RotationOrderYZX: ClassVar[XformCommonAPI.RotationOrder] = ...
    RotationOrderZXY: ClassVar[XformCommonAPI.RotationOrder] = ...
    RotationOrderZYX: ClassVar[XformCommonAPI.RotationOrder] = ...
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @classmethod
    def CanConvertOpTypeToRotationOrder(cls, opType: XformOp.Type) -> bool: ...
    @classmethod
    def ConvertOpTypeToRotationOrder(cls, opType: XformOp.Type) -> XformCommonAPI.RotationOrder: ...
    @classmethod
    def ConvertRotationOrderToOpType(cls, rotationOrder: XformCommonAPI.RotationOrder) -> XformOp.Type: ...
    @overload
    def CreateXformOps(self, rotationOrder: XformCommonAPI.RotationOrder, op1: XformCommonAPI.OpFlags = ..., op2: XformCommonAPI.OpFlags = ..., op3: XformCommonAPI.OpFlags = ..., op4: XformCommonAPI.OpFlags = ...) -> tuple: ...
    @overload
    def CreateXformOps(self, op1: XformCommonAPI.OpFlags = ..., op2: XformCommonAPI.OpFlags = ..., op3: XformCommonAPI.OpFlags = ..., op4: XformCommonAPI.OpFlags = ...) -> tuple: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> XformCommonAPI: ...
    def GetResetXformStack(self) -> bool: ...
    @classmethod
    def GetRotationTransform(cls, rotation: pxr.Gf.Vec3f | list[float] | tuple[float, float, float], rotationOrder: XformCommonAPI.RotationOrder) -> pxr.Gf.Matrix4d: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    def GetXformVectors(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> tuple: ...
    def GetXformVectorsByAccumulation(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> tuple: ...
    def SetPivot(self, pivot: pxr.Gf.Vec3f | list[float] | tuple[float, float, float], time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> bool: ...
    def SetResetXformStack(self, resetXformStack: bool) -> bool: ...
    def SetRotate(self, rotation: pxr.Gf.Vec3f | list[float] | tuple[float, float, float], rotationOrder: XformCommonAPI.RotationOrder = ..., time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> bool: ...
    def SetScale(self, scale: pxr.Gf.Vec3f | list[float] | tuple[float, float, float], time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> bool: ...
    def SetTranslate(self, translation: pxr.Gf.Vec3d | list[float] | tuple[float, float, float], time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> bool: ...
    def SetXformVectors(self, translation: pxr.Gf.Vec3d | list[float] | tuple[float, float, float], rotation: pxr.Gf.Vec3f | list[float] | tuple[float, float, float], scale: pxr.Gf.Vec3f | list[float] | tuple[float, float, float], pivot: pxr.Gf.Vec3f | list[float] | tuple[float, float, float], rotationOrder: XformCommonAPI.RotationOrder, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> bool: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class XformOp(Boost.Python.instance):
    class Precision(pxr.Tf.Tf_PyEnumWrapper):
        _baseName: ClassVar[str] = ...
        allValues: ClassVar[tuple] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        def GetValueFromName(self, name: object) -> Any: ...
        def __reduce__(self) -> Any: ...
    class Type(pxr.Tf.Tf_PyEnumWrapper):
        _baseName: ClassVar[str] = ...
        allValues: ClassVar[tuple] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        def GetValueFromName(self, name: object) -> Any: ...
        def __reduce__(self) -> Any: ...
    PrecisionDouble: ClassVar[XformOp.Precision] = ...
    PrecisionFloat: ClassVar[XformOp.Precision] = ...
    PrecisionHalf: ClassVar[XformOp.Precision] = ...
    TypeInvalid: ClassVar[pxr.Tf.Type] = ...
    TypeOrient: ClassVar[pxr.Tf.Type] = ...
    TypeRotateX: ClassVar[pxr.Tf.Type] = ...
    TypeRotateXYZ: ClassVar[pxr.Tf.Type] = ...
    TypeRotateXZY: ClassVar[pxr.Tf.Type] = ...
    TypeRotateY: ClassVar[pxr.Tf.Type] = ...
    TypeRotateYXZ: ClassVar[pxr.Tf.Type] = ...
    TypeRotateYZX: ClassVar[pxr.Tf.Type] = ...
    TypeRotateZ: ClassVar[pxr.Tf.Type] = ...
    TypeRotateZXY: ClassVar[pxr.Tf.Type] = ...
    TypeRotateZYX: ClassVar[pxr.Tf.Type] = ...
    TypeScale: ClassVar[pxr.Tf.Type] = ...
    TypeTransform: ClassVar[pxr.Tf.Type] = ...
    TypeTranslate: ClassVar[pxr.Tf.Type] = ...
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, attr: pxr.Usd.Attribute | ConstraintTarget | Primvar | XformOp | pxr.UsdShade.Input | pxr.UsdShade.Output, isInverseOp: bool = ...) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def Get(self, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> T: ...
    def GetAttr(self) -> pxr.Usd.Attribute: ...
    def GetBaseName(self) -> str: ...
    def GetName(self) -> str: ...
    def GetNamespace(self) -> str: ...
    def GetNumTimeSamples(self) -> int: ...
    @classmethod
    def GetOpName(cls) -> Any: ...
    @classmethod
    def GetOpTransform(cls, arg2: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode) -> pxr.Gf.Matrix4d: ...
    def GetOpType(self) -> pxr.Tf.Type: ...
    @classmethod
    def GetOpTypeEnum(cls, arg1: str | pxr.Ar.ResolvedPath) -> pxr.Tf.Type: ...
    @classmethod
    def GetOpTypeToken(cls, arg1: pxr.Tf.Type) -> str: ...
    def GetPrecision(self) -> XformOp.Precision: ...
    def GetTimeSamples(self) -> list[float]: ...
    def GetTimeSamplesInInterval(self, arg2: pxr.Gf.Interval) -> list[float]: ...
    def GetTypeName(self) -> pxr.Sdf.ValueTypeName: ...
    def IsDefined(self) -> bool: ...
    def IsInverseOp(self) -> bool: ...
    def MightBeTimeVarying(self) -> bool: ...
    def Set(self, value: T, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> bool: ...
    def SplitName(self) -> list[str]: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __reduce__(self) -> Any: ...

class XformOpTypes(Boost.Python.instance):
    orient: ClassVar[Any] = ...  # read-only
    resetXformStack: ClassVar[Any] = ...  # read-only
    rotateX: ClassVar[Any] = ...  # read-only
    rotateXYZ: ClassVar[Any] = ...  # read-only
    rotateXZY: ClassVar[Any] = ...  # read-only
    rotateY: ClassVar[Any] = ...  # read-only
    rotateYXZ: ClassVar[Any] = ...  # read-only
    rotateYZX: ClassVar[Any] = ...  # read-only
    rotateZ: ClassVar[Any] = ...  # read-only
    rotateZXY: ClassVar[Any] = ...  # read-only
    rotateZYX: ClassVar[Any] = ...  # read-only
    scale: ClassVar[Any] = ...  # read-only
    transform: ClassVar[Any] = ...  # read-only
    translate: ClassVar[Any] = ...  # read-only
    def __init__(self, *args, **kwargs) -> None: ...
    def __reduce__(self) -> Any: ...

class Xformable(Imageable):
    __instance_size__: ClassVar[int] = ...
    @overload
    def __init__(self, prim: pxr.Usd.Prim) -> None: ...
    @overload
    def __init__(self, schemaObj: pxr.Usd.SchemaBase) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def AddOrientOp(self, precision: XformOp.Precision = ..., opSuffix: str | pxr.Ar.ResolvedPath = ..., isInverseOp: bool = ...) -> XformOp: ...
    def AddRotateXOp(self, precision: XformOp.Precision = ..., opSuffix: str | pxr.Ar.ResolvedPath = ..., isInverseOp: bool = ...) -> XformOp: ...
    def AddRotateXYZOp(self, precision: XformOp.Precision = ..., opSuffix: str | pxr.Ar.ResolvedPath = ..., isInverseOp: bool = ...) -> XformOp: ...
    def AddRotateXZYOp(self, precision: XformOp.Precision = ..., opSuffix: str | pxr.Ar.ResolvedPath = ..., isInverseOp: bool = ...) -> XformOp: ...
    def AddRotateYOp(self, precision: XformOp.Precision = ..., opSuffix: str | pxr.Ar.ResolvedPath = ..., isInverseOp: bool = ...) -> XformOp: ...
    def AddRotateYXZOp(self, precision: XformOp.Precision = ..., opSuffix: str | pxr.Ar.ResolvedPath = ..., isInverseOp: bool = ...) -> XformOp: ...
    def AddRotateYZXOp(self, precision: XformOp.Precision = ..., opSuffix: str | pxr.Ar.ResolvedPath = ..., isInverseOp: bool = ...) -> XformOp: ...
    def AddRotateZOp(self, precision: XformOp.Precision = ..., opSuffix: str | pxr.Ar.ResolvedPath = ..., isInverseOp: bool = ...) -> XformOp: ...
    def AddRotateZXYOp(self, precision: XformOp.Precision = ..., opSuffix: str | pxr.Ar.ResolvedPath = ..., isInverseOp: bool = ...) -> XformOp: ...
    def AddRotateZYXOp(self, precision: XformOp.Precision = ..., opSuffix: str | pxr.Ar.ResolvedPath = ..., isInverseOp: bool = ...) -> XformOp: ...
    def AddScaleOp(self, precision: XformOp.Precision = ..., opSuffix: str | pxr.Ar.ResolvedPath = ..., isInverseOp: bool = ...) -> XformOp: ...
    def AddTransformOp(self, precision: XformOp.Precision = ..., opSuffix: str | pxr.Ar.ResolvedPath = ..., isInverseOp: bool = ...) -> XformOp: ...
    def AddTranslateOp(self, precision: XformOp.Precision = ..., opSuffix: str | pxr.Ar.ResolvedPath = ..., isInverseOp: bool = ...) -> XformOp: ...
    def AddXformOp(self, opType: XformOp.Type, precision: XformOp.Precision = ..., opSuffix: str | pxr.Ar.ResolvedPath = ..., isInverseOp: bool = ...) -> XformOp: ...
    def ClearXformOpOrder(self) -> bool: ...
    def CreateXformOpOrderAttr(self, defaultValue: Any = ..., writeSparsely: bool = ...) -> pxr.Usd.Attribute: ...
    @classmethod
    def Get(cls, stage: pxr.Usd.Stage, path: pxr.Sdf.Path | str) -> Xformable: ...
    @overload
    @classmethod
    def GetLocalTransformation(cls, ops: object, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> pxr.Gf.Matrix4d: ...
    @overload
    @classmethod
    def GetLocalTransformation(cls, time: pxr.Usd.TimeCode | float | pxr.Sdf.TimeCode = ...) -> pxr.Gf.Matrix4d: ...
    def GetOrderedXformOps(self) -> list: ...
    def GetResetXformStack(self) -> bool: ...
    @classmethod
    def GetSchemaAttributeNames(cls, includeInherited: bool = ...) -> list[str]: ...
    @classmethod
    def GetTimeSamples(cls) -> list: ...
    @classmethod
    def GetTimeSamplesInInterval(cls, arg2: pxr.Gf.Interval) -> list: ...
    def GetXformOpOrderAttr(self) -> pxr.Usd.Attribute: ...
    @classmethod
    def IsTransformationAffectedByAttrNamed(cls, arg1: str | pxr.Ar.ResolvedPath) -> bool: ...
    def MakeMatrixXform(self) -> XformOp: ...
    def SetResetXformStack(self, resetXform: bool) -> bool: ...
    def SetXformOpOrder(self, orderedXformOps: typing.Iterable[XformOp], resetXformStack: bool = ...) -> bool: ...
    @overload
    def TransformMightBeTimeVarying(self, arg2: typing.Iterable[XformOp]) -> bool: ...
    @overload
    def TransformMightBeTimeVarying(self) -> bool: ...
    @classmethod
    def _GetStaticTfType(cls) -> pxr.Tf.Type: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> Any: ...

class _CanApplyResult(Boost.Python.instance):
    __instance_size__: ClassVar[int] = ...
    def __init__(self, arg2: bool, arg3: object) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, arg2: int) -> Any: ...
    def __iter__(self) -> typing.Iterator[Any]: ...
    def __ne__(self, other: object) -> bool: ...
    def __reduce__(self) -> Any: ...
    @property
    def whyNot(self) -> Any: ...

def GetFallbackUpAxis() -> str: ...
def GetStageMetersPerUnit(stage: pxr.Usd.Stage) -> float: ...
def GetStageUpAxis(stage: pxr.Usd.Stage) -> str: ...
def LinearUnitsAre(authoredUnits: float, standardUnits: float, epsilon: float = ...) -> bool: ...
def SetStageMetersPerUnit(stage: pxr.Usd.Stage, metersPerUnit: float) -> bool: ...
def SetStageUpAxis(stage: pxr.Usd.Stage, upAxis: str | pxr.Ar.ResolvedPath) -> bool: ...
def StageHasAuthoredMetersPerUnit(stage: pxr.Usd.Stage) -> bool: ...