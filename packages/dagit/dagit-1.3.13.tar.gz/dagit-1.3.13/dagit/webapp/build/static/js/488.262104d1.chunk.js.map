{"version":3,"file":"static/js/488.262104d1.chunk.js","mappings":"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","sources":["../../core/src/app/titleOfIO.ts","../../core/src/graph/layout.ts","../../../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../../../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../../../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js"],"sourcesContent":["export const DEFAULT_RESULT_NAME = 'result';\n\nexport const titleOfIO = (i: {solid: {name: string}; definition: {name: string}}) => {\n  return i.solid.name !== DEFAULT_RESULT_NAME\n    ? `${i.solid.name}:${i.definition.name}`\n    : i.solid.name;\n};\n","import * as dagre from 'dagre';\n\nimport {titleOfIO} from '../app/titleOfIO';\n\nimport {IBounds, IPoint} from './common';\n\nexport type OpLayoutEdgeSide = {\n  point: IPoint;\n  opName: string;\n  edgeName: string;\n};\n\nexport type OpLayoutEdge = {\n  from: OpLayoutEdgeSide;\n  to: OpLayoutEdgeSide;\n};\n\nexport interface OpLayout {\n  // Overall frame of the box relative to 0,0 on the graph\n  bounds: IBounds;\n\n  // Frames of specific components - These need to be computed during layout\n  // (rather than at render time) to position edges into inputs/outputs.\n  op: IBounds;\n  inputs: {[inputName: string]: OpLayoutIO};\n  outputs: {[outputName: string]: OpLayoutIO};\n}\n\nexport interface OpLayoutIO {\n  layout: IBounds;\n  label: boolean;\n  collapsed: string[];\n  port: IPoint;\n}\n\nexport type OpGraphLayout = {\n  width: number;\n  height: number;\n  parent: ParentOpLayout | null;\n  edges: OpLayoutEdge[];\n  nodes: {[opName: string]: OpLayout};\n};\n\ninterface ParentOpLayout extends Omit<OpLayout, 'op'> {\n  mappingLeftEdge: number;\n  mappingLeftSpacing: number;\n  dependsOn: {[opName: string]: IPoint};\n  dependedBy: {[opName: string]: IPoint};\n  invocationBoundingBox: IBounds;\n}\n\nexport interface ILayoutOp {\n  name: string;\n  inputs: {\n    definition: {\n      name: string;\n    };\n    dependsOn: {\n      definition: {\n        name: string;\n      };\n      solid: {\n        name: string;\n      };\n    }[];\n  }[];\n  definition: {\n    description: string | null;\n    assetNodes: {\n      assetKey: {\n        path: string[];\n      };\n    }[];\n  };\n  outputs: {\n    definition: {\n      name: string;\n    };\n    dependedBy: {\n      definition: {\n        name: string;\n      };\n      solid: {\n        name: string;\n      };\n    }[];\n  }[];\n}\n\nconst OP_WIDTH = 370;\nconst OP_BASE_HEIGHT = 52;\nconst OP_ASSETS_ROW_HEIGHT = 22;\nconst IO_HEIGHT = 26;\nconst IO_INSET = 0;\nconst IO_MINI_WIDTH = 35;\nconst IO_THRESHOLD_FOR_MINI = 4;\nconst PORT_INSET_X = 13;\nconst PORT_INSET_Y = IO_HEIGHT / 2;\nconst PARENT_DEFINITION_PADDING = 70;\nconst PARENT_INVOCATION_PADDING = 70;\nconst EXTERNAL_DEPENDENCY_PADDING = 50;\n\nconst MARGIN_BASE = 100;\n\ntype OpLinkInfo = {\n  solid: {name: string};\n  definition: {name: string};\n};\n\nfunction flattenIO(arrays: OpLinkInfo[][]) {\n  const map: {[key: string]: OpLinkInfo} = {};\n  arrays.forEach((array) => array.forEach((item) => (map[titleOfIO(item)] = item)));\n  return Object.values(map);\n}\n\nexport function layoutOpGraph(pipelineOps: ILayoutOp[], parentOp?: ILayoutOp): OpGraphLayout {\n  const g = new dagre.graphlib.Graph();\n\n  // First, identify how much space we need to pad the DAG by in order to show the\n  // parent op AROUND it. We pass this padding in to dagre, and then we have enough\n  // room to add our parent layout around the result.\n  let parentIOPadding = 0;\n  let marginy = MARGIN_BASE;\n  let marginx = MARGIN_BASE;\n  if (parentOp) {\n    parentIOPadding = Math.max(parentOp.inputs.length, parentOp.outputs.length) * IO_HEIGHT;\n    marginx = PARENT_DEFINITION_PADDING + PARENT_INVOCATION_PADDING;\n    marginy = marginx + parentIOPadding;\n  }\n\n  // Define a new top-down, left to right graph layout\n  g.setGraph({rankdir: 'TB', marginx, marginy});\n  g.setDefaultEdgeLabel(() => ({}));\n\n  const edges: OpLayoutEdge[] = [];\n  const opNamesPresent: {[name: string]: boolean} = {};\n\n  pipelineOps.forEach((op) => {\n    opNamesPresent[op.name] = true;\n  });\n  pipelineOps.forEach((op) => {\n    // Lay out each op individually to get it's width and height based on it's\n    // inputs and outputs, and then attach it to the graph. Dagre will give us it's\n    // x,y position.\n    const layout = layoutOp(op, {x: 0, y: 0});\n    g.setNode(op.name, {\n      width: layout.bounds.width,\n      height: layout.bounds.height,\n    });\n\n    // Give Dagre the dependency edges and build a flat set of them so we\n    // can reference them in a single pass later\n    op.inputs.forEach((input) => {\n      input.dependsOn.forEach((dep) => {\n        if (opNamesPresent[dep.solid.name] && opNamesPresent[op.name]) {\n          g.setEdge({v: dep.solid.name, w: op.name}, {weight: 1});\n\n          edges.push({\n            from: {\n              point: {x: 0, y: 0},\n              opName: dep.solid.name,\n              edgeName: dep.definition.name,\n            },\n            to: {\n              point: {x: 0, y: 0},\n              opName: op.name,\n              edgeName: input.definition.name,\n            },\n          });\n        }\n      });\n    });\n  });\n\n  dagre.layout(g);\n\n  const ops: {[opName: string]: OpLayout} = {};\n  const dagreNodes: {[opName: string]: dagre.Node} = {};\n  g.nodes().forEach(function (opName) {\n    const node = g.node(opName);\n    if (!node) {\n      return;\n    }\n    dagreNodes[opName] = node;\n  });\n\n  // Due to a bug in Dagre when run without an \"align\" value, we need to calculate\n  // the total width of the graph coordinate space ourselves. We need the height\n  // because we've shifted long single rows into multiple rows.\n  let maxWidth = 0;\n  let maxHeight = 0;\n\n  // Read the Dagre layout and map \"nodes\" back to our solids, but with\n  // X,Y coordinates this time.\n  Object.entries(dagreNodes).forEach(([opName, node]) => {\n    const op = pipelineOps.find(({name}) => name === opName);\n    if (!op) {\n      return;\n    }\n\n    const x = node.x - node.width / 2; // Dagre's x/y is the center, we want top left\n    const y = node.y - node.height / 2;\n    ops[opName] = layoutOp(op, {x, y});\n    maxWidth = Math.max(maxWidth, x + node.width);\n    maxHeight = Math.max(maxHeight, y + node.height);\n  });\n\n  // Read the Dagre layout and map \"edges\" back to our data model. We don't\n  // currently use the \"closest points on the node\" Dagre suggests (but we could).\n  g.edges().forEach(function (e) {\n    const conn = edges.find((c) => c.from.opName === e.v && c.to.opName === e.w);\n    const points = g.edge(e).points;\n    if (conn && points.length > 0) {\n      conn.from.point = points[0]!;\n      conn.to.point = points[points.length - 1]!;\n    }\n  });\n\n  const result: OpGraphLayout = {\n    edges,\n    nodes: ops,\n    width: maxWidth + marginx,\n    height: maxHeight + marginy,\n    parent: null,\n  };\n\n  if (parentOp) {\n    // Now that we've computed the pipeline layout fully, lay out the\n    // composite op around the completed DAG.\n    result.parent = layoutParentGraphOp(result, parentOp, parentIOPadding);\n  }\n\n  return result;\n}\n\nfunction layoutParentGraphOp(layout: OpGraphLayout, op: ILayoutOp, parentIOPadding: number) {\n  const result: ParentOpLayout = {\n    invocationBoundingBox: {\n      x: 1,\n      y: 1,\n      width: layout.width - 1,\n      height: layout.height - 1,\n    },\n    bounds: {\n      x: PARENT_INVOCATION_PADDING,\n      y: PARENT_INVOCATION_PADDING + parentIOPadding,\n      width: layout.width - PARENT_INVOCATION_PADDING * 2,\n      height: layout.height - (PARENT_INVOCATION_PADDING + parentIOPadding) * 2,\n    },\n    mappingLeftEdge: PARENT_INVOCATION_PADDING - 20,\n    mappingLeftSpacing: 10,\n    inputs: {},\n    outputs: {},\n    dependsOn: layoutExternalConnections(\n      flattenIO(op.inputs.map((d) => d.dependsOn)),\n      -EXTERNAL_DEPENDENCY_PADDING,\n      layout.width,\n    ),\n    dependedBy: layoutExternalConnections(\n      flattenIO(op.outputs.map((d) => d.dependedBy)),\n      layout.height + EXTERNAL_DEPENDENCY_PADDING,\n      layout.width,\n    ),\n  };\n\n  const boundingBottom = result.bounds.y + result.bounds.height;\n\n  op.inputs.forEach((input, idx) => {\n    result.inputs[input.definition.name] = {\n      layout: {\n        x: result.bounds.x,\n        y: result.bounds.y - idx * IO_HEIGHT - IO_HEIGHT,\n        width: 0,\n        height: IO_HEIGHT,\n      },\n      collapsed: [],\n      label: true,\n      port: {\n        x: result.bounds.x + PORT_INSET_X,\n        y: result.bounds.y - idx * IO_HEIGHT - IO_HEIGHT / 2,\n      },\n    };\n  });\n\n  op.outputs.forEach((output, idx) => {\n    result.outputs[output.definition.name] = {\n      layout: {\n        x: result.bounds.x,\n        y: boundingBottom + idx * IO_HEIGHT,\n        width: 0,\n        height: IO_HEIGHT,\n      },\n      collapsed: [],\n      label: true,\n      port: {\n        x: result.bounds.x + PORT_INSET_X,\n        y: boundingBottom + idx * IO_HEIGHT + IO_HEIGHT / 2,\n      },\n    };\n  });\n\n  return result;\n}\n\nfunction layoutExternalConnections(links: OpLinkInfo[], y: number, layoutWidth: number) {\n  // fill evenly from 0 to layoutWidth from left to right, then center them if there's overflow.\n  const inset = PARENT_INVOCATION_PADDING + PORT_INSET_X;\n  const insetWidth = layoutWidth - inset * 2;\n  const spacing = Math.max(200, insetWidth / links.length);\n  const baseX = inset + Math.min(0, (insetWidth - links.length * spacing) / 2);\n  const yShift = spacing < 300 ? 20 : 0;\n\n  const result: {[opName: string]: IPoint} = {};\n  links.forEach((link, idx) => {\n    const shiftDirection = 1 - (idx % 2) * 2; // 1 or -1, alternating\n    result[titleOfIO(link)] = {\n      x: baseX + idx * spacing,\n      y: y + yShift * shiftDirection,\n    };\n  });\n  return result;\n}\n\nexport function layoutOp(op: ILayoutOp, root: IPoint): OpLayout {\n  // Starting at the root (top left) X,Y, return the layout information for an op with\n  // input blocks, then the main block, then output blocks (arranged vertically).\n  //\n  // This code \"appends\" boxes vertically, advancing accY as it goes.\n  let accY = root.y;\n\n  const appendMiniIODots = <T extends ILayoutOp['inputs'][0] | ILayoutOp['outputs'][0]>(\n    ios: T[],\n    sortKey: (io: T) => string,\n    clusteringKey: (io: T) => string,\n  ) => {\n    // Sort both input and output boxes displayed on the graph alphabetically based on the input name.\n    // This means that if two ops are connected to each other multiple times, the lines do not cross.\n    const sorted = [...ios].sort((a, b) => sortKey(a).localeCompare(sortKey(b)));\n\n    let x = 0;\n    let last: OpLayoutIO;\n    let lastKey: string | null = null;\n    const layouts: {[name: string]: OpLayoutIO} = {};\n    const spacing = Math.min(IO_MINI_WIDTH, OP_WIDTH / (sorted.length + 1));\n\n    // Add \"port\" layouts, collapsing the dots if they are connected to the same opposing solid\n    // (eg: two inputs connected to the same upstream output) with a \"[O] + 2\" style.\n    sorted.forEach((io, _idx) => {\n      const key = clusteringKey(io);\n      if (key !== lastKey) {\n        lastKey = key;\n        last = {\n          port: {\n            x: root.x + x + PORT_INSET_X,\n            y: accY + PORT_INSET_Y,\n          },\n          collapsed: [],\n          label: false,\n          layout: {\n            x: root.x + x,\n            y: accY,\n            width: IO_MINI_WIDTH,\n            height: IO_HEIGHT,\n          },\n        };\n        layouts[io.definition.name] = last;\n        x += spacing;\n      } else {\n        if (last.collapsed.length === 0) {\n          x += 15;\n        }\n        last.collapsed.push(io.definition.name);\n      }\n    });\n\n    // Center the items on the op rather than left justifying them\n    const centeringAdjustment = (OP_WIDTH - (x - PORT_INSET_X + IO_MINI_WIDTH)) / 2;\n    Object.values(layouts).forEach((l) => {\n      l.layout.x += centeringAdjustment;\n      l.port.x += centeringAdjustment;\n    });\n\n    // Place the next box beneath the\n    accY += IO_HEIGHT;\n\n    return layouts;\n  };\n\n  const appendStackedIOBoxes = (ios: ILayoutOp['inputs'] | ILayoutOp['outputs']) => {\n    const layouts: {[name: string]: OpLayoutIO} = {};\n    ios.forEach((io) => {\n      layouts[io.definition.name] = {\n        port: {x: root.x + PORT_INSET_X, y: accY + PORT_INSET_Y},\n        label: true,\n        collapsed: [],\n        layout: {\n          x: root.x,\n          y: accY,\n          width: 0,\n          height: IO_HEIGHT,\n        },\n      };\n      accY += IO_HEIGHT;\n    });\n    return layouts;\n  };\n\n  const inputLayouts =\n    op.inputs.length > IO_THRESHOLD_FOR_MINI\n      ? appendMiniIODots(\n          op.inputs,\n          (input) => input.definition.name,\n          (input) => input.dependsOn[0]?.solid.name || '',\n        )\n      : appendStackedIOBoxes(op.inputs);\n\n  const opLayout: IBounds = {\n    x: root.x,\n    y: Math.max(root.y, accY - IO_INSET),\n    width: OP_WIDTH,\n    height: OP_BASE_HEIGHT + IO_INSET * 2,\n  };\n\n  accY += OP_BASE_HEIGHT;\n\n  if (op.definition.assetNodes.length && op.definition.description) {\n    opLayout.height += OP_ASSETS_ROW_HEIGHT;\n    accY += OP_ASSETS_ROW_HEIGHT;\n  }\n\n  const outputLayouts =\n    op.outputs.length > IO_THRESHOLD_FOR_MINI\n      ? appendMiniIODots(\n          op.outputs,\n          (o) => o.dependedBy[0]?.definition.name || '',\n          (o) => o.dependedBy[0]?.solid.name || '',\n        )\n      : appendStackedIOBoxes(op.outputs);\n\n  return {\n    bounds: {\n      x: root.x - 5,\n      y: root.y - 5,\n      width: OP_WIDTH + 10,\n      height: accY - root.y + 10,\n    },\n    op: opLayout,\n    inputs: inputLayouts,\n    outputs: outputLayouts,\n  };\n}\n","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}"],"names":["titleOfIO","i","solid","name","concat","definition","OP_WIDTH","OP_BASE_HEIGHT","OP_ASSETS_ROW_HEIGHT","IO_HEIGHT","IO_INSET","IO_MINI_WIDTH","IO_THRESHOLD_FOR_MINI","PORT_INSET_X","PORT_INSET_Y","PARENT_DEFINITION_PADDING","PARENT_INVOCATION_PADDING","EXTERNAL_DEPENDENCY_PADDING","MARGIN_BASE","flattenIO","arrays","map","forEach","array","item","Object","values","layoutOpGraph","pipelineOps","parentOp","g","dagre","parentIOPadding","marginy","marginx","Math","max","inputs","length","outputs","setGraph","rankdir","setDefaultEdgeLabel","edges","opNamesPresent","op","layout","layoutOp","x","y","setNode","width","bounds","height","input","dependsOn","dep","setEdge","v","w","weight","push","from","point","opName","edgeName","to","ops","dagreNodes","nodes","node","maxWidth","maxHeight","entries","_ref","_ref2","_slicedToArray","find","_ref3","e","conn","c","points","edge","result","parent","invocationBoundingBox","mappingLeftEdge","mappingLeftSpacing","layoutExternalConnections","d","dependedBy","boundingBottom","idx","collapsed","label","port","output","layoutParentGraphOp","links","layoutWidth","inset","insetWidth","spacing","baseX","min","yShift","link","shiftDirection","root","accY","appendMiniIODots","ios","sortKey","clusteringKey","last","sorted","_toConsumableArray","sort","a","b","localeCompare","lastKey","layouts","io","_idx","key","centeringAdjustment","l","appendStackedIOBoxes","inputLayouts","_input$dependsOn$","opLayout","assetNodes","description","outputLayouts","o","_o$dependedBy$","_o$dependedBy$2","_iterableToArray","iter","Symbol","iterator","Array","arr","isArray","arrayLikeToArray","iterableToArray","unsupportedIterableToArray","TypeError"],"sourceRoot":""}