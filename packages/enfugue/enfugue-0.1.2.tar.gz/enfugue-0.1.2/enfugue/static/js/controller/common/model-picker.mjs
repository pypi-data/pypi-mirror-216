import{Controller}from"../base.mjs";import{TableView}from"../../view/table.mjs";import{View}from"../../view/base.mjs";import{FormView}from"../../view/forms/base.mjs";import{SearchListInputView}from"../../view/forms/input.mjs";import{isEmpty,waitFor}from"../../base/helpers.mjs";import{ElementBuilder}from"../../base/builder.mjs";const E=new ElementBuilder;class ModelPickerInputView extends SearchListInputView{static placeholder="Start typing to search modelsâ€¦"}class ModelTensorRTTableView extends TableView{constructor(t,e,i){super(t,e),this.buildEngine=i}static canSort=!1;static columnFormatters={Build:function(t,e){if(!0===t)return E.span().content("Ready");{let i=E.button().content("Build").on("click",(async()=>{try{i.disabled(!0).addClass("loading-bar loading"),await this.buildEngine(e),i.removeClass("loading-bar").removeClass("loading").content("Ready")}catch(t){i.removeClass("loading-bar loading").disabled(!1)}}));return"building"===t&&i.disabled(!0).addClass("loading-bar loading"),i}}}}class ModelTensorRTStatusView extends View{static tagNam="enfugue-tensorrt-status-view";static supportedNetworks={unet:"UNet",controlled_unet:"Controlled UNet",inpaint_unet:"Inpainting UNet"};static tensorRTDescription=["TensorRT is a technology created by Nvidia that transforms an AI model into one that takes advantage of hardware acceleration available on Nvidia GPUs.","As there are numerous varying architectures used by Nvidia that support this technology, these engines must be compiled by an architecture compatible with your actual hardware, rather than distributed by AI model providers.","The compilation time for each model varies, but generally takes between 15 and 30 minutes each. You can expect between 50% and 100% faster inference speeds during the engine's respective step(s).","The compiled engine is only useable for a model with the same checkpoint, LoRA, Textual Inversion and engine size. If you change any of those details about this model, it will require recompilation. You can safely change model prompts as desired without requiring a new engine."];static networkDescriptions={unet:"The network used when creating images with a prompt or base image.",controlled_unet:"The network used when creating images with a control image.",inpaint_unet:"The network used when inpainting or outpainting."};constructor(t,e,i){super(t),this.status=e,this.buildEngine=i}get tableData(){return Object.getOwnPropertyNames(this.constructor.supportedNetworks).map((t=>({"Network Name":this.constructor.supportedNetworks[t],Description:this.constructor.networkDescriptions[t],Build:this.status.building===t?"building":this.status[`${t}_ready`]})))}getNameFromLabel(t){for(let e in this.constructor.supportedNetworks)if(this.constructor.supportedNetworks[e]===t)return e;throw`Unknown network ${t}`}async build(){let t=await super.build(),e=new ModelTensorRTTableView(this.config,this.tableData,(t=>this.buildEngine(this.getNameFromLabel(t["Network Name"]))));for(let e of this.constructor.tensorRTDescription)t.append(E.p().class("margin").content(e));return t.append(await e.getNode())}}class ModelPickerFormView extends FormView{static className="model-picker";static autoSubmit=!0;static fieldSets={Model:{model:{class:ModelPickerInputView}}};static tensorRTLogo="/static/img/brand/tensorrt.png";setTensorRTStatus(t,e){let i=this.node.find("#tensorrt");if(t.supported){let s=ModelTensorRTStatusView.supportedNetworks,n=Object.getOwnPropertyNames(s),o=n.length,a=n.reduce(((e,i)=>(e[i]=t[`${i}_ready`],e)),{}),r=Object.values(a).filter((t=>t)).length;isEmpty(i)?(i=E.div().id("tensorrt").append(E.img().src(this.constructor.tensorRTLogo),E.span().class("fraction").content(E.span().content(`${r}`),E.span().content(`${o}`))).on("click",(()=>e())),this.node.append(i)):i.off("click").on("click",(()=>e())).find("span.fraction").content(E.span().content(`${r}`),E.span().content(`${o}`)),t.ready?i.addClass("ready").data("tooltip","TensorRT is <strong>ready</strong>"):i.removeClass("ready").data("tooltip","TensorRT is <strong>not ready</strong>")}else isEmpty(i)||this.node.remove(i)}}class ModelPickerController extends Controller{static tensorRTStatusWindowWidth=500;static tensorRTStatusWindowHeight=750;getState(){return{model:this.formView.values}}getDefaultState(){return{model:null}}setState(t){isEmpty(t.model)||this.formView.setValues(t.model).then((()=>this.formView.submit()))}async buildEngine(t,e){await this.model.post(`/models/${t}/tensorrt/${e}`),this.notify("info","Build Started","The engine will be busy throughout this TensorRT build. You will see a notification when it is complete, and the status indicator in the top bar will show ready or idle."),await waitFor((()=>(console.log("Built engines are",this.builtEngines),!isEmpty(this.builtEngines[t])&&-1!==this.builtEngines[t].indexOf(e))),{interval:5e3})}async showBuildTensorRT(t){let e=await t.getTensorRTStatus(),i=await this.getCurrentEngineBuildProcess();isEmpty(i)||i.metadata.tensorrt_build.model!==t.name||(e.building=i.metadata.tensorrt_build.network);let s=new ModelTensorRTStatusView(this.config,e,(e=>this.buildEngine(t.name,e)));return await this.spawnWindow(`${t.name} TensorRT Status`,s,this.constructor.tensorRTStatusWindowWidth,this.constructor.tensorRTStatusWindowHeight)}async getCurrentEngineBuildProcess(){let t=await this.model.get("/invocation");for(let e of t)if(void 0!==e.metadata&&void 0!==e.metadata.tensorrt_build&&-1!==["queued","processing"].indexOf(e.status))return e;return null}async initialize(){this.builtEngines={},ModelPickerInputView.defaultOptions=async()=>(await this.model.DiffusionModel.queryAll()).map((t=>t.name)),this.formView=new ModelPickerFormView(this.config),this.formView.onSubmit((async t=>{try{let e=await this.model.DiffusionModel.query({name:t.model}),i=await e.getTensorRTStatus();this.publish("modelPickerChange",e),this.engine.model=t.model,this.formView.setTensorRTStatus(i,(()=>this.showBuildTensorRT(e)))}catch(t){this.formView.setValues({model:null})}})),this.application.container.appendChild(await this.formView.render()),this.subscribe("invocationError",(t=>{if(console.error(t),!isEmpty(t.metadata)&&!isEmpty(t.metadata.tensorrt_build)){let e=t.metadata.tensorrt_build.network,i=ModelTensorRTStatusView.supportedNetworks[e],s=t.metadata.tensorrt_build.model;this.notify("info","TensorRT Engine Build Failed",`${s} ${i} TensorRT Engine failed to build. Please try again.`),isEmpty(this.builtEngines[s])&&(this.builtEngines[s]=[]),this.builtEngines[s].push(e)}})),this.subscribe("invocationComplete",(t=>{if(!isEmpty(t.metadata)&&!isEmpty(t.metadata.tensorrt_build)){let e=t.metadata.tensorrt_build.network,i=ModelTensorRTStatusView.supportedNetworks[e],s=t.metadata.tensorrt_build.model;this.notify("info","TensorRT Engine Build Complete",`Successfully built ${s} ${i} TensorRT Engine.`),isEmpty(this.builtEngines[s])&&(this.builtEngines[s]=[]),this.builtEngines[s].push(e)}}))}}export{ModelPickerController};
