# AUTOGENERATED FILE! PLEASE DON'T EDIT HERE. EDIT THE SOURCE NOTEBOOKS INSTEAD
"""This module for tools that will likely start the processing stream."""
from typing import Iterator, Union, Any, List
import k1lib, urllib, subprocess, warnings, os, k1lib, threading, time, warnings, math, io, dill, urllib, validators
from collections import deque
from k1lib.cli import BaseCli; import k1lib.cli as cli
from k1lib.cli.typehint import *
from contextlib import contextmanager
requests = k1lib.dep("requests")
try: import minio; hasMinio = True
except: hasMinio = False
__all__ = ["cat", "splitSeek", "refineSeek", "wget", "ls", "cmd", "walk", "requireCli", "urlPath", "kzip", "kunzip", "unzip"]
settings = k1lib.settings.cli
class NoPartialContent(Exception): pass                                          # NoPartialContent
def getChunk(url:str, sB:int, eB:int, timeout:float, retries:int) -> bytes: # start inclusive, end exclusive # getChunk
    for i in range(retries):                                                     # getChunk
        try: res = requests.get(url, headers={"Range": f"bytes={sB}-{eB-1}"}, timeout=timeout) # getChunk
        except Exception as e:                                                   # getChunk
            if i >= retries-1: raise Exception(f"Can't get file chunk")          # getChunk
            continue                                                             # getChunk
        if res.status_code != 206: raise NoPartialContent(f"Server doesn't allow partial downloads at this particular url. Status code: {res.status_code}") # getChunk
        return res.content                                                       # getChunk
def getChunks(url:str, sB:int, eB:int, chunkSize=None, chunkTimeout:float=10, chunkRetries:int=10) -> List[bytes]: # getChunks
    """Grabs bytes from sB to eB in chunks"""                                    # getChunks
    chunkSize = chunkSize or settings.cli.cat.chunkSize                          # getChunks
    return range(sB, eB+1) | cli.batched(chunkSize, True) | cli.apply(lambda r: getChunk(url, r.start, r.stop-1, chunkTimeout, chunkRetries)) # getChunks
catSettings = k1lib.Settings().add("chunkSize", 100000, "file reading chunk size for binary+chunk mode. Decrease it to avoid wasting memory and increase it to avoid disk latency") # getChunks
catSettings.add("every", k1lib.Settings().add("text", 1000, "for text mode, will print every n lines").add("binary", 10, "for binary mode, will print every n 100000-byte blocks"), "profiler print frequency") # getChunks
settings.add("cat", catSettings, "inp.cat() settings")                           # getChunks
                                                                                 # getChunks
rfS = k1lib.Settings()                                                           # getChunks
settings.add("RemoteFile", rfS, "inp.RemoteFile() settings, used in cat(), splitSeek() and the like") # getChunks
rfS.add("memoryLimit", 100_000_000, "if the internal cache exceeds this limit (in bytes), and randomAccess is False, then old downloaded chunks will be deleted") # getChunks
rfS.add("timeout", 10, "seconds before terminating the remote request and retrying") # getChunks
rfS.add("retries", 10, "how many times to retry sending the request before giving up") # getChunks
def noPartial(url, *args):                                                       # noPartial
    try: return len(getChunk(url, 0, 10, *args)) != 10                           # noPartial
    except NoPartialContent: return True                                         # noPartial
class RemoteFile:                                                                # RemoteFile
    def __init__(self, url, randomAccess=True, blockSize=None, noPartialConfirm=False, timeout:float=None, retries:int=None): # RemoteFile
        """
:param url: url of the remote file
:param randomAccess: is random accessing parts of the file expected? If
    True, then keeps all of the reads in ram internally, else free them
    as soon as possible
:param blockSize: all reads will fetch roughly this amount of bytes"""           # RemoteFile
        self.url = url; self.randomAccess = randomAccess; self.blockSize = blockSize or settings.cat.chunkSize # RemoteFile
        self.noPartialConfirm = noPartialConfirm; self.size = None; self.domain = k1lib.Domain() # RemoteFile
        self.seekPos = 0; self.reads = deque() # List[sB, eB, content]           # RemoteFile
        self._confirmMsgShown = False; self.timeout = timeout or rfS.timeout; self.retries = retries or rfS.retries # RemoteFile
        self._totalReadSize = 0; self.noPartial = noPartial(url, self.timeout, self.retries) # RemoteFile
    def _fetch(self, sB:int, eB:int): # fetches from start to end byte and dumps to internal memory. Inclusive start and end byte # RemoteFile
        if not self.noPartial:                                                   # RemoteFile
            eB = max(eB, min(sB+self.blockSize, len(self)))                      # RemoteFile
            chunk = getChunk(self.url, sB, eB, self.timeout, self.retries)       # RemoteFile
        else:                                                                    # RemoteFile
            if self.noPartialConfirm and not self._confirmMsgShown:              # RemoteFile
                ans = input(f"""Remote file '{self.url}' don't support partial downloads.
Therefore the entire file will be loaded into RAM, which
could be undesireable. Do you want to continue? Y/n: """)                        # RemoteFile
                self._confirmMsgShown = True                                     # RemoteFile
                if ans.lower()[0] != "y": self.reads.append([0, 0, b""]); return # RemoteFile
            sB = 0; chunk = requests.get(self.url).content; eB = len(chunk)      # RemoteFile
        self.reads.append([sB, eB, chunk])                                       # RemoteFile
        self._totalReadSize += len(chunk); self.domain = self.domain + k1lib.Domain([sB, eB]) # RemoteFile
        if not self.randomAccess and self._totalReadSize > rfS.memoryLimit: # deletes old reads # RemoteFile
            sB, eB, chunk = self.reads.popleft()                                 # RemoteFile
            self._totalReadSize -= len(chunk)                                    # RemoteFile
    def _ensureRange(self, sB, eB): # makes sure that all ranges between sB and eB are available # RemoteFile
        missingDomain = k1lib.Domain([max(sB-30, 0), min(eB+30, len(self))]) & -self.domain # RemoteFile
        for sB, eB in missingDomain.ranges: self._fetch(sB, eB)                  # RemoteFile
    def _readChunks(self, sB, eB): # read from sB to eB, but in chunks, to be optimized. inclusive sB, exclusive eB # RemoteFile
        sB = max(min(sB, len(self)), 0); eB = max(min(eB, len(self)), 0); self._ensureRange(sB, eB) # RemoteFile
        return self.reads | cli.filt(~cli.aS(lambda s,e,chunk: e>=sB and s<=eB)) | cli.sort() | ~cli.apply(lambda s,e,chunk: chunk[max(sB-s, 0):len(chunk)+min(eB-e, 0)]) | cli.filt(len) # RemoteFile
    def seek(self, cookie, whence=0):                                            # RemoteFile
        if whence == 0: self.seekPos = cookie                                    # RemoteFile
        elif whence == 1: self.seekPos += cookie                                 # RemoteFile
        elif whence == 2: self.seekPos = len(self) + cookie                      # RemoteFile
        else: raise Exception("Invalid whence")                                  # RemoteFile
        return self.seekPos                                                      # RemoteFile
    def read(self, size, join=True):                                             # RemoteFile
        chunks = self._readChunks(self.seekPos, self.seekPos + size)             # RemoteFile
        self.seekPos += size; return b"".join(chunks) if join else chunks        # RemoteFile
    def readline(self, newLine=True):                                            # RemoteFile
        ans = []; seekPos = self.seekPos                                         # RemoteFile
        try:                                                                     # RemoteFile
            while self.seekPos < len(self):                                      # RemoteFile
                for chunk in self.read(self.blockSize, False):                   # RemoteFile
                    if len(chunk) == 0: raise SyntaxError()                      # RemoteFile
                    ans.append(chunk)                                            # RemoteFile
                    if b"\n" in chunk: raise SyntaxError()                       # RemoteFile
        except SyntaxError: pass                                                 # RemoteFile
        ans = b"".join(ans)                                                      # RemoteFile
        try: n = ans.index(b"\n")                                                # RemoteFile
        except ValueError: n = len(ans) # only happens at end of file            # RemoteFile
        self.seekPos = seekPos + n+1; return (ans[:n+1] if newLine else ans[:n]).decode() # RemoteFile
    def readlines(self, newLine=True):                                           # RemoteFile
        while True:                                                              # RemoteFile
            yield self.readline(newLine)                                         # RemoteFile
            if self.seekPos >= len(self): break                                  # RemoteFile
    def tell(self): return self.seekPos                                          # RemoteFile
    def _getSize(self):                                                          # RemoteFile
        if self.noPartial: self._fetch(0, 10); return self.reads[0][1]           # RemoteFile
        for i in range(self.retries):                                            # RemoteFile
            try: return requests.head(self.url, timeout=self.timeout).headers.items() | cli.apply(cli.op().lower(), 0) | cli.toDict() | cli.op()["content-length"].ab_int() # RemoteFile
            except Exception as e:                                               # RemoteFile
                if i >= self.retries: raise Exception(f"Can't get size of remote file: {e}") # RemoteFile
    def __len__(self):                                                           # RemoteFile
        if self.size is None: self.size = self._getSize()                        # RemoteFile
        return self.size                                                         # RemoteFile
    def __repr__(self): return f"<RemoteFile url={self.url} size={k1lib.fmt.size(len(self))}>" # RemoteFile
@contextmanager                                                                  # RemoteFile
def openFile(fn, text, noPartialConfirm=False): # can be actual file or url      # openFile
    if not isinstance(fn, str): yield fn; return # file handle case, just return itself # openFile
    if os.path.exists(fn):                                                       # openFile
        if text:                                                                 # openFile
            with open(fn, "r", settings.cat.chunkSize) as f: yield f             # openFile
        else:                                                                    # openFile
            with open(fn, "rb", settings.cat.chunkSize) as f: yield f            # openFile
    elif validators.url(fn) is True:                                             # openFile
        yield RemoteFile(fn, False, noPartialConfirm=noPartialConfirm)           # openFile
    else: raise FileNotFoundError(f"The file {fn} doesn't seem to exist and/or it's not a valid url") # openFile
def _catGenText(fn, sB, eB): # fn for "file name"                                # _catGenText
    try:                                                                         # _catGenText
        if sB == 0 and eB == -1: # fast path without bounds (90-160 MB/s expected) # _catGenText
            with openFile(fn, True) as f:                                        # _catGenText
                while True:                                                      # _catGenText
                    line = f.readline()                                          # _catGenText
                    if line == "": return                                        # _catGenText
                    yield line[:-1] if line[-1] == "\n" else line                # _catGenText
        else: # slow path with bounds (15 MB/s expected). Update: much faster now, expect only 40% slower than the path above # _catGenText
            sB = wrap(fn, sB); eB = wrap(fn, eB)                                 # _catGenText
            with openFile(fn, True) as f:                                        # _catGenText
                f.seek(sB); b = sB # current byte                                # _catGenText
                while True:                                                      # _catGenText
                    line = f.readline(); b += len(line)                          # _catGenText
                    if line == "": return                                        # _catGenText
                    if b > eB: yield line[:len(line)-(b-eB)]; return             # _catGenText
                    yield line[:-1] if line[-1] == "\n" else line                # _catGenText
    except FileNotFoundError: pass                                               # _catGenText
def _catGenBin(fn, sB, eB):                                                      # _catGenBin
    chunkSize = settings.cat.chunkSize; sB = wrap(fn, sB); eB = wrap(fn, eB); nB = eB - sB # number of bytes to read total # _catGenBin
    with openFile(fn, False) as f:                                               # _catGenBin
        f.seek(sB); nChunks = math.ceil(nB / chunkSize); lastChunkSize = nB - chunkSize*(nChunks-1) # _catGenBin
        # had to do this because RemoteFile is actually not thread-safe          # _catGenBin
        # applyF = (lambda f_: cli.apply(f_)) if isinstance(f, RemoteFile) else (lambda f_: cli.applyTh(f_, prefetch=10)) # _catGenBin
        applyF = (lambda f_: cli.apply(f_)) # actually, normal reads are not thread-safe either. Stupid me # _catGenBin
        yield from range(nChunks) | applyF(lambda i: f.read(chunkSize) if i < nChunks-1 else f.read(chunkSize)[:lastChunkSize]) # _catGenBin
def fileLength(fn):                                                              # fileLength
    with openFile(fn, False) as f: return f.seek(0, os.SEEK_END)                 # fileLength
def wrap(fn, b): return b if b >= 0 else b + fileLength(fn) + 1                  # wrap
class _cat(BaseCli):                                                             # _cat
    def __init__(self, text, chunks, sB, eB): self.text = text; self.chunks = chunks; self.sB = sB; self.eB = eB # _cat
    def _typehint(self, ignored=None):                                           # _cat
        if self.text: return tIter(str) if self.chunks else tList(str)           # _cat
        else: return tIter(bytes) if self.chunks else bytes                      # _cat
    def __ror__(self, fn:Union[str, "fileHandle"]) -> Union[Iterator[str], bytes]: # _cat
        text = self.text; chunks = self.chunks; sB = self.sB; eB = self.eB; fn = os.path.expanduser(fn) if isinstance(fn, str) else fn # _cat
        if text and chunks and k1lib._settings.packages.k1a and isinstance(fn, str) and os.path.exists(fn): # _cat
            return k1lib._k1a.k1a.StrIterCat(fn, sB, eB) # accelerated C version # _cat
        if chunks: return _catGenText(fn, sB, eB) if text else _catGenBin(fn, sB, eB) # _cat
        sB = wrap(fn, sB); eB = wrap(fn, eB)                                     # _cat
        if text:                                                                 # _cat
            with openFile(fn, True) as f: f.seek(sB); return f.read(eB-sB).splitlines() # _cat
        else:                                                                    # _cat
            with openFile(fn, False) as f: f.seek(sB); return f.read(eB-sB)      # _cat
class Profile(BaseCli):                                                          # Profile
    def __init__(self, text): self.data = []; self.text = text                   # Profile
    def __ror__(self, it):                                                       # Profile
        fmt = k1lib.fmt; chars = 0; beginTime = time.time()                      # Profile
        if self.text:                                                            # Profile
            a, b, c, d, f = k1lib.ConstantPad.multi(5); every = settings.cat.every.text # Profile
            for lines, e in enumerate(it):                                       # Profile
                chars += len(e)                                                  # Profile
                if lines % every == 0: # every 1000 lines, print stuff out       # Profile
                    elapsed = time.time() - beginTime#; self.data.append([lines, chars, elapsed]) # Profile
                    print(f"Current line: {fmt.item(lines) | a} ({fmt.item(lines/elapsed) | b} lines/s), current byte/chars: {fmt.size(chars) | c} ({fmt.size(chars/elapsed) | d}/s), elapsed: {fmt.time(elapsed) | f}                                 ", end="\r") # Profile
                yield e                                                          # Profile
        else:                                                                    # Profile
            a, b, c = k1lib.ConstantPad.multi(3); every = settings.cat.every.binary # Profile
            for i, e in enumerate(it):                                           # Profile
                chars += len(e)                                                  # Profile
                if i % every == 0: # every 10 100000-byte chunks, print stuff out # Profile
                    elapsed = time.time() - beginTime#; self.data.append([chars, elapsed]) # Profile
                    print(f"Current size/chars: {fmt.size(chars) | a} ({fmt.size(chars/elapsed) | b}/s), elapsed: {fmt.time(elapsed) | c}                                 ", end="\r") # Profile
                yield e                                                          # Profile
def cat(fileName:str=None, text:bool=True, chunks:bool=None, profile:bool=False, sB=0, eB=-1): # cat
    """Reads a file line by line.
Example::

    # display first 10 lines of file
    cat("file.txt") | headOut()
    # piping in also works
    "file.txt" | cat() | headOut()

    # read bytes from an image file and dumps it to another file
    cat("img.png", False) | file("img2.png")

If you want to read only specific sections of the file, you can specify the
start (``sB``) and end byte (``eB``) like this::

    "123456\\n89" | file("test/catTest.pth")
    # returns ['3456', '8']
    cat("test/catTest.pth", sB=2, eB=8) | deref()

    settings.cat.context.chunkSize=3 # just for demonstration, don't do it normally
    # returns [b'123', b'456', b'\\n8']
    cat("test/catTest.pth", text=False, chunks=True, eB=8) | deref()

.. admonition:: Remote files

    You can also read from urls directly, like this::

        cat("https://k1lib.com/latest/") | deref()

    For remote files like this, there are extra settings at :data:`~k1lib.settings`.cli.RemoteFile.
    This will also read the file chunk by chunk if required. If the website doesn't support
    partial downloads, then all of it will be downloaded and stored into ram, which may not be
    desireable. The available settings are:

    - timeout: seconds before killing the existing request
    - retries: try to resend the request for this much before giving up

If you are working with large files and would like to read 1 file from multiple
threads/processes, then you can use this cli in conjunction with :class:`splitSeek`.

If you are dumping multiple pickled objects into a single file, you can read all
of them using :meth:`cat.pickle`.

This cli has lots of settings at :data:`~k1lib.settings`.cli.cat

:param fileName: if None, then return a :class:`~k1lib.cli.init.BaseCli`
    that accepts a file name and outputs Iterator[str]
:param text: if True, read text file, else read binary file
:param chunks: if True then reads the file chunk by chunk, else reads the
    entire file. Defaults to True in text mode and False in binary mode
:param profile: whether to profile the file reading rate or not. Can adjust
    printing frequency using `settings.cli.cat.every`
:param sB: "start byte". Specify this if you want to start reading from this byte
:param eB: "end byte", exclusive. Default -1 means end of file"""                # cat
    if chunks is None: chunks = True if text else False                          # cat
    if profile and not chunks: warnings.warn(f"Can't profile reading rate when you're trying to read everything at once"); profile = False # cat
    f = _cat(text, chunks, sB, eB)                                               # cat
    if profile: f = f | Profile(text)                                            # cat
    return f if fileName is None else fileName | f                               # cat
def _catPickle(fileName=None, pickleModule=dill):                                # _catPickle
    """Reads a file as a series of pickled objects.
Example::

    "ab" | aS(dill.dumps) | file("test/catTest.pth")
    "cd" | aS(dill.dumps) >> file("test/catTest.pth") # append to the file
    # returns ["ab", "cd"]
    cat.pickle("test/catTest.pth") | deref()
    # also returns ["ab", "cd"], same style as :class:`cat`
    "test/catTest.pth" | cat.pickle() | deref()

:param fileName: name of the pickled file
:param pickleModule: pickle module to use. Python's default is "pickle", but
    I usually use :mod:`dill` because it's more robust"""                        # _catPickle
    def gen(fn):                                                                 # _catPickle
        with open(os.path.expanduser(fn), "rb") as f:                            # _catPickle
            try:                                                                 # _catPickle
                while True: yield dill.load(f)                                   # _catPickle
            except: pass                                                         # _catPickle
    return cli.aS(gen) if fileName is None else fileName | cli.aS(gen)           # _catPickle
cat.pickle = _catPickle                                                          # _catPickle
class splitSeek(BaseCli):                                                        # splitSeek
    def __init__(self, n=None, c=b'\n', ws=None):                                # splitSeek
        """Splits a file up into n fragments aligned to the closest character and return the seek points.
Example::

    # preparing the large file
    range(120) | apply(lambda x: f"{x:3}_56789") | file("test/largeFile.txt")
    # returns [0, 30, 70, 110, 150, 190, 230, 270, 300, 340]
    "test/largeFile.txt" | splitSeek(31) | head()
    # returns 32
    "test/largeFile.txt" | splitSeek(31) | shape(0)
    # returns 32, demonstrating you can also pipe file objects in, if that's what you want
    open("test/largeFile.txt") | splitSeek(31) | shape(0)
    # returns [0, 0, 10, 10, 20, 30, 30, 40, 40, 50], notice some segments have zero length
    "test/largeFile.txt" | splitSeek(200) | head()
    # returns [0, 400, 1200], demonstrating that you can split a file up unevenly by weights
    "test/largeFile.txt" | splitSeek(ws=[1, 2]) | deref()

So, the generated file has 120 lines in total. Each line is 10 bytes (9 for
the string, and 1 for the new line character). Splitting the file into 31
fragments will result in 32 seek points (:math:`p_i\quad i\in[1, n+1]`). You
can then use these seek points to read the file in multiple threads/processes
using :meth:`cat`, like this::

    # returns [['  0_56789', '  1_56789', '  2_56789'], ['  3_56789', '  4_56789', '  5_56789', '  6_56789']]
    "test/largeFile.txt" | splitSeek(31) | window(2) | ~apply(lambda sB, eB: cat("test/largeFile.txt", sB=sB, eB=eB-1)) | head(2) | deref()

Because :math:`120/31\\approx4`, most of cat's reads contain 4 lines, but some
has 3 lines. Also notice that the lines smoothly transitions between cat's
reads (``2_56789`` to ``3_56789``), so that's pretty nice. Just like with :meth:`cat`,
this also works with urls::

    "https://example.com" | splitSeek(10)

.. warning::

    You have to really test whether reading the same file from multiple processes is
    going to be really faster or not. If your data is stored in a HDD (aka hard drive,
    with spinning disks), then it will actually slow you down (10x-100x), because the
    disk will have to context switch all the time, and each switch has a 10ms cost.

    You also have to take into account collecting together the results of all processes,
    which can bottleneck the cpu. Read more about concurrency pitfalls at :class:`~k1lib.cli.modifier.applyMp`.

In some scenarios where you want to adjust the seek points even more, like when
you want to parse FASTA genome files, which has blocks of 2/4 lines each like this:

.. code-block:: text

    @FP200005993L1C001R00100000061/2
    TTTTAAACTTGCATTCTTTGGAGATTTGCTGAGTGTTGCTAGAGCTGGGAAACTTTTTTAATGAGATACGTGCATATTTTTCAAATTTACAGATCTTTTTTCACAAAAATAGAAAGTCATAAATGTGAAATGGAAACCTAAACAAGGCAA
    +
    GFEEEDEFGFFFFEFFFFFIFCEEEFFFGFFDFEGEDGFFFGDGFFGDGCE@GGGEEFDFGFGCFDFGGHCHFFFGFFFFFGEFDFFGHGFGEEHGFGEGFGFHFFEGFFFE;GEGEFGGHFFEI=GDAEDIFDDFGHFGEFGFEGGGGF
    @FP200005993L1C001R00100000167/2
    CTGGAATTTGGTATCTTATTGCCAAAGAATCTGTTTTGTGAAACTTGGGATCTCTATTTTAATGTTAATTCTGGTCAGTTGTGCCTAAACTCCATAAAGCAGGGACTATACTGAGGCGTATTCAATCTTCCTTCTTACCAAGGCCAGGAA
    +
    EEFECEDEFFCGFFFFFEEEGEGFEDECCEFEFDFEEFDFEDDFEFEEFDDFFEEFFEEFEFFHEEFEEFEFFDEFFFECF>FFFEFEDFCFFFEGFEDEEGDDFEEFEFGEEBD@EG>EEFFECEEGFEEEFFEDGEEEDE5EBDG:CC

Here, each 4 lines are (title, read, blank, quality). Because by default, this will
only split neatly along new lines, you will have to write extra functions to detect
if a particular seek point is desirable, and if not, either jump forward or backward
using :meth:`splitSeek.forward` and :meth:`splitSeek.backward`. To help with this,
:class:`refineSeek` has some useful methods that you might want to check out.

:param n: how many splits do you want?
:param c: block-boundary character, usually just the new line character
:param ws: weights. If given, the splits length ratios will roughly correspond to this""" # splitSeek
        self.n = n; self.c = c; self.ws = ws; self.fn = None; self.res = None # file name, result # splitSeek
        if ws is None and n is None: raise Exception("Specify at least n or ws for splitSeek to work") # splitSeek
    @staticmethod                                                                # splitSeek
    def forward(f, i:int, c=b'\n') -> int:                                       # splitSeek
        """Returns char location after the search char, going forward.
Example::

    f = io.BytesIO(b"123\\n456\\n789\\nabc")
    f | splitSeek(2) # returns [0, 4, 15]
    splitSeek.forward(f, 2) # returns 4
    splitSeek.forward(f, 3) # returns 4
    splitSeek.forward(f, 4) # returns 8

:param f: file handle
:param i: current seek point
:param c: block-boundary character"""                                            # splitSeek
        def inner(f):                                                            # splitSeek
            f.seek(i)                                                            # splitSeek
            while True:                                                          # splitSeek
                b = f.tell(); s = f.read(1000); di = s.find(c)                   # splitSeek
                if di > -1: return b + di + 1                                    # splitSeek
                if s == "": return -1                                            # splitSeek
        if isinstance(f, str):                                                   # splitSeek
            with openFile(os.path.expanduser(f), False) as _f: return inner(_f)  # splitSeek
        else: return inner(f)                                                    # splitSeek
    @staticmethod                                                                # splitSeek
    def backward(f, i:int, c=b'\n') -> int:                                      # splitSeek
        """Returns char location after the search char, going backward.
Example::

    f = io.BytesIO(b"123\\n456\\n789\\nabc")
    f | splitSeek(2) # returns [0, 4, 15]
    splitSeek.backward(f, 5) # returns 4
    splitSeek.backward(f, 4) # returns 4
    splitSeek.backward(f, 3) # returns 0

:param f: file handle
:param i: current seek point
:param c: block-boundary character"""                                            # splitSeek
        def inner(f):                                                            # splitSeek
            mul = 1                                                              # splitSeek
            while True:                                                          # splitSeek
                begin = max(i-1000*mul, 0); end = max(i-1000*(mul-1), 0); mul += 1 # search range # splitSeek
                f.seek(begin); b = f.tell(); s = f.read(end-begin); di = s.rfind(c) # splitSeek
                if di > -1: return b + di + 1                                    # splitSeek
                if b == 0: return 0                                              # splitSeek
        if isinstance(f, str):                                                   # splitSeek
            with openFile(os.path.expanduser(f), False) as _f: return inner(_f)  # splitSeek
        else: return inner(f)                                                    # splitSeek
    def __ror__(self, fn): # why return self instead of the seek positions directly? Because we want to pass along dependencies like file name to downstream processes like refineSeek # splitSeek
        if isinstance(fn, str): fn = os.path.expanduser(fn)                      # splitSeek
        n = self.n; c = self.c; ws = self.ws; self.fn = fn                       # splitSeek
        def func(f):                                                             # splitSeek
            f.seek(0, os.SEEK_END); end = f.tell()                               # splitSeek
            if ws is None: begins = range(n) | cli.apply(lambda x: int(x*end/n)) # splitSeek
            else: begins = range(end) | cli.splitW(*ws) | cli.apply(lambda x: x.start) # splitSeek
            return [*begins | cli.apply(lambda x: splitSeek.backward(f, x, c)), end] # splitSeek
        if isinstance(fn, str):                                                  # splitSeek
            with openFile(os.path.expanduser(fn), False, True) as f: self.res = func(f); return self # splitSeek
        else: self.res = func(fn); return self                                   # splitSeek
    def __or__(self, aft):                                                       # splitSeek
        if self.res is None: return super().__or__(aft)                          # splitSeek
        return aft.__ror__(self)                                                 # splitSeek
    def __getitem__(self, idx): return self.res[idx]                             # splitSeek
    def __len__(self): return len(self.res)                                      # splitSeek
    def __iter__(self): return iter(self.res)                                    # splitSeek
    def __repr__(self): return self.res.__repr__()                               # splitSeek
class refineSeek(BaseCli):                                                       # refineSeek
    def __init__(self, f=None, window=1):                                        # refineSeek
        """Refines seek positions.
Example::

    # returns list of integers for seek positions
    "abc.txt" | splitSeek(30)
    # returns refined seek positions, such that the line starting at the seek positions starts with "@"
    "abc.txt" | splitSeek(30) | refineSeek(lambda x: x.startswith(b"@"))
    # same thing as above
    "abc.txt" | splitSeek(30) | refineSeek(lambda x: x[0] == b"@"[0])
    # returns refined seek positions, such that 0th line starts with "@" and 2nd line starts with "+". This demonstrates `window` parameter
    "abc.txt" | splitSeek(30) | refineSeek(lambda x: x[0][0] == b"@"[0] and x[2][0] == b"+"[0], 3)
    # same thing as above, demonstrating some builtin refine seek functions
    "abc.txt" | splitSeek(30) | refineSeek.fastq()

:param f: function that returns True if the current line/lines is a valid block boundary
:param window: by default (1), will fetch 1 line and check boundary using ``f(line)``.
    If a value greater than 1 is passed (for example, 3), will fetch 3 lines and check
    boundary using ``f([line1, line2, line3])``
"""                                                                              # refineSeek
        if f is None: f = lambda x: True                                         # refineSeek
        self.f = cli.fastF(f); self.window = window; self.fn = None              # refineSeek
    def __ror__(self, seeks):                                                    # refineSeek
        f = self.f; window = self.window                                         # refineSeek
        def read(fio, sB:int):                                                   # refineSeek
            fio.seek(sB)                                                         # refineSeek
            if window == 1: return fio.readline()                                # refineSeek
            return list(cli.repeatF(lambda: fio.readline(), window))             # refineSeek
        if len(seeks) <= 2: return seeks                                         # refineSeek
        fn = self.fn or seeks.fn; newSeeks = [seeks[0]]                          # refineSeek
        def process(fio):                                                        # refineSeek
            with openFile(fn, False) as fio:                                     # refineSeek
                for seek in seeks[1:-1]:                                         # refineSeek
                    line = read(fio, seek)                                       # refineSeek
                    while not f(line): seek = splitSeek.forward(fio, seek); line = read(fio, seek) # refineSeek
                    newSeeks.append(seek)                                        # refineSeek
            newSeeks.append(seeks[-1]); return newSeeks                          # refineSeek
        if isinstance(fn, str):                                                  # refineSeek
            with openFile(fn, False) as fio: return process(fio)                 # refineSeek
        else: return process(fn)                                                 # refineSeek
    def injectFn(self, fn):                                                      # refineSeek
        """Injects file name dependency, if this is not used right after :class:`splitSeek`""" # refineSeek
        self.fn = fn; return self                                                # refineSeek
    @classmethod                                                                 # refineSeek
    def fastq(cls):                                                              # refineSeek
        """Refine fastq file's seek points"""                                    # refineSeek
        return cls(lambda x: x[0][0] == b"@"[0] and x[2][0] == b"+"[0], 3)       # refineSeek
def wget(url:str, fileName:str=None, mkdir=True):                                # wget
    """Downloads a file. Also returns the file name, in case you want to pipe it
to something else.

:param url: The url of the file
:param fileName: if None, then tries to infer it from the url
:param mkdir: whether to make the directory leading up to the file or not"""     # wget
    if fileName is None: fileName = url.split("/")[-1]                           # wget
    fileName = os.path.expanduser(fileName); dirname = os.path.dirname(fileName) # wget
    if mkdir: os.makedirs(dirname, exist_ok=True)                                # wget
    try: urllib.request.urlretrieve(url, fileName); return fileName              # wget
    except: return None                                                          # wget
def ls(folder:str=None):                                                         # ls
    """List every file and folder inside the specified folder.
Example::

    # returns List[str]
    ls("/home")
    # same as above
    "/home" | ls()
    # only outputs files, not folders
    ls("/home") | filt(os.path.isfile)"""                                        # ls
    if folder is None: return _ls()                                              # ls
    else: return folder | _ls()                                                  # ls
class _ls(BaseCli):                                                              # _ls
    def _typehint(self, ignored=None): return tList(str)                         # _ls
    def __ror__(self, path:str):                                                 # _ls
        path = os.path.expanduser(path.rstrip(os.sep))                           # _ls
        return [f"{path}{os.sep}{e}" for e in os.listdir(path)]                  # _ls
k1lib.settings.cli.add("quiet", False, "whether to mute extra outputs from clis or not") # _ls
newline = b'\n'[0]                                                               # _ls
class lazySt:                                                                    # lazySt
    def __init__(self, st, text:bool):                                           # lazySt
        """Converts byte stream into lazy text/byte stream, with nice __repr__.""" # lazySt
        self.st = st; self.text = text;                                          # lazySt
    def __iter__(self):                                                          # lazySt
        if self.text:                                                            # lazySt
            while True:                                                          # lazySt
                line = self.st.readline()                                        # lazySt
                if len(line) == 0: break                                         # lazySt
                yield line.decode().rstrip("\n")                                 # lazySt
        else:                                                                    # lazySt
            while True:                                                          # lazySt
                line = self.st.readline()                                        # lazySt
                if len(line) == 0: break                                         # lazySt
                yield line                                                       # lazySt
    def __repr__(self): self | cli.stdout(); return ""                           # lazySt
def executeCmd(cmd:str, inp:bytes, text):                                        # executeCmd
    """Runs a command, and returns stdout and stderr streams"""                  # executeCmd
    p = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=k1lib.settings.wd) # executeCmd
    if inp is not None:                                                          # executeCmd
        if isinstance(inp, (str, bytes)): p.stdin.write(inp if isinstance(inp, bytes) else inp.encode()) # executeCmd
        else:                                                                    # executeCmd
            for e in inp:                                                        # executeCmd
                if not isinstance(e, (str, bytes)): e = str(e)                   # executeCmd
                if not isinstance(e, bytes): e = e.encode()                      # executeCmd
                p.stdin.write(e); p.stdin.write(b"\n")                           # executeCmd
    p.stdin.close(); return p, lazySt(p.stdout, text), lazySt(p.stderr, text)    # executeCmd
def printStderr(err):                                                            # printStderr
    if not k1lib.settings.cli.quiet:                                             # printStderr
        e, it = err | cli.peek()                                                 # printStderr
        if it != []: it | cli.insert("\nError encountered:\n") | cli.apply(k1lib.fmt.txt.red) | cli.stdout() # printStderr
def requireCli(cliTool:str):                                                     # requireCli
    """Searches for a particular cli tool (eg. "ls"), throws ImportError if not
found, else do nothing"""                                                        # requireCli
    a = cmd(cliTool); None | a;                                                  # requireCli
    if len(a.err) > 0: raise ImportError(f"""Can't find cli tool {cliTool}. Please install it first.""") # requireCli
class cmd(BaseCli):                                                              # cmd
    def __init__(self, cmd:str, mode:int=1, text=True, block=False): # 0: return (stdout, stderr). 1: return stdout, 2: return stderr # cmd
        """Runs a command, and returns the output line by line. Can pipe in some
inputs. If no inputs then have to pipe in :data:`None`. Example::

    # return detailed list of files
    None | cmd("ls -la")
    # return list of files that ends with "ipynb"
    None | cmd("ls -la") | cmd('grep ipynb$')

It might be tiresome to pipe in :data:`None` all the time. So, you can use ">"
operator to yield values right away::

    # prints out first 10 lines of list of files
    cmd("ls -la") > headOut()

If you're using Jupyter notebook/lab, then if you were to display a :class:`cmd`
object, it will print out the outputs. So, a single command ``cmd("mkdir")``
displayed at the end of a cell is enough to trigger creating the directory.

Reminder that ">" operator in here sort of has a different meaning to that of
:class:`~k1lib.cli.init.BaseCli`. So you kinda have to becareful about this::

    # returns a serial cli, cmd not executed
    cmd("ls -la") | deref()
    # executes cmd with no input stream and pipes output to deref
    cmd("ls -la") > deref()
    # returns a serial cli
    cmd("ls -la") > grep("txt") > headOut()
    # executes pipeline
    cmd("ls -la") > grep("txt") | headOut()

General advice is, right ater a :class:`cmd`, use ">", and use "|" everywhere else.

Let's see a few more exotic examples. File ``a.sh``:

.. code-block:: bash

    #!/bin/bash

    echo 1; sleep 0.5
    echo This message goes to stderr >&2
    echo 2; sleep 0.5
    echo $(</dev/stdin)
    sleep 0.5; echo 3

Examples::

    # returns [b'1\\n', b'2\\n', b'45\\n', b'3\\n'] and prints out the error message
    "45" | cmd("./a.sh", text=False) | deref()
    # returns [b'This message goes to stderr\\n']
    "45" | cmd("./a.sh", mode=2, text=False) | deref()
    # returns [[b'1\\n', b'2\\n', b'45\\n', b'3\\n'], [b'This message goes to stderr\\n']]
    "45" | cmd("./a.sh", mode=0, text=False) | deref()

Performance-wise, stdout and stderr will yield values right away as soon
as the process outputs it, so you get real time feedback. However, this will
convert the entire input into a :class:`bytes` object, and not feed it bit by
bit lazily, so if you have a humongous input, it might slow you down a little.

Also, because stdout and stderr yield values right away, it means that if you
want the operation to be blocking until finished, you have to consume the output::

    None | cmd("mkdir abc")
    # might fail, because this might get executed before the previous line
    None | cmd("echo a>abc/rg.txt")

    None | cmd("mkdir abc") | ignore()
    # will succeed, because this will be guaranteed to execute after the previous line
    None | cmd("echo a>abc/rg.txt")

Settings:
- cli.quiet: if True, won't display errors in mode 1

:param mode: if 0, returns ``(stdout, stderr)``. If 1, returns ``stdout`` and prints
    ``stderr`` if there are any errors. If 2, returns ``stderr``
:param text: whether to decode the outputs into :class:`str` or return raw :class:`bytes`
:param block: whether to wait for the task to finish before returning to Python or not""" # cmd
        super().__init__(); self.cmd = cmd; self.mode = mode                     # cmd
        self.text = text; self.block = block; self.ro = k1lib.RunOnce()          # cmd
    def _typehint(self, ignored=None):                                           # cmd
        t = tIter(str) if self.text else tIter(bytes)                            # cmd
        if self.mode == 0: return tCollection(t, t)                              # cmd
        return t                                                                 # cmd
    def __ror__(self, it:Union[None, str, bytes, Iterator[Any]]) -> Iterator[Union[str, bytes]]: # cmd
        """Pipes in lines of input, or if there's nothing to
pass, then pass None"""                                                          # cmd
        if not self.ro.done(): self.p, self.out, self.err = executeCmd(self.cmd, it, self.text); mode = self.mode # cmd
        if self.block:                                                           # cmd
            self.out = self.out | cli.deref()                                    # cmd
            self.err = self.err | cli.deref()                                    # cmd
        if mode == 0: return (self.out, self.err)                                # cmd
        elif mode == 1:                                                          # cmd
            threading.Thread(target=lambda: printStderr(self.err)).start()       # cmd
            return self.out                                                      # cmd
        elif mode == 2: return self.err                                          # cmd
    def __gt__(self, it): return None | self | it                                # cmd
    def __repr__(self):                                                          # cmd
        return (None | self).__repr__()                                          # cmd
class walk(BaseCli):                                                             # walk
    def __init__(self, **kwargs):                                                # walk
        """Recursively get all files inside a dictionary.
Example::

    # prints out first 10 files
    "." | walk() | headOut()"""                                                  # walk
        self.kwargs = kwargs                                                     # walk
    def __ror__(self, path):                                                     # walk
        return os.walk(path, **self.kwargs) | ~cli.apply(lambda x, y, z: z | cli.apply(lambda e: x + os.sep + e)) | cli.joinStreams() # walk
def urlPath(base:str, host:bool=True):                                           # urlPath
    """Translates from a url to a file path.
Example::

    base = "~/ssd/some/other/path"
    url = "http://example.com/some/path/to/file.txt"
    url | urlPath(base) # returns "~/ssd/some/other/path/example_com/some/path/to/file.txt"
    url | urlPath(base, False) # returns "~/ssd/some/other/path/some/path/to/file.txt"

:param base: base directory you want the files to be in"""                       # urlPath
    base = base.rstrip("/\\")                                                    # urlPath
    def inner(url):                                                              # urlPath
        p = urllib.parse.urlparse(url)                                           # urlPath
        a = (p.netloc.replace(".", "_") + os.sep) if host else ""                # urlPath
        return f"{base}{os.sep}{a}{p.path.strip('/')}".replace("//", "/")        # urlPath
    return cli.aS(inner)                                                         # urlPath
import bz2, gzip, zlib                                                           # urlPath
puremagic = k1lib.dep("puremagic")                                               # urlPath
class kzip(BaseCli):                                                             # kzip
    def __init__(self, fmt="gz"):                                                # kzip
        """Incrementally compresses a stream of data using gzip or bzip2.
Example::

    data = range(100) | apply(lambda x: str(x).encode()) | deref() # list of bytes
    data | kzip() | deref() # returns list of bytes
    range(100) | apply(str) | kzip() | deref() # returns list of bytes, demonstrating piping iterator of string works

Quick reminder that if you pass in bytes iterator then it will be compressed as-is.
But if you pass in string iterator then it will append a new line character to each
string and then compress it. This is more intuitive, and it makes the style consistent
with :class:`~k1lib.cli.output.file`.

Passing in single string or byte is ok too::

    "0123456789" | kzip()  # returns gz bytes
    b"0123456789" | kzip() # returns gz bytes, exact same pattern as above

Why "kzip" and not just "zip"? Because "zip" is a builtin python keyword.

See also: :class:`kunzip`

:param fmt: desired compressed format. Currently only supports "gz" or "bz2"
"""                                                                              # kzip
        fmt = fmt.strip(".")                                                     # kzip
        if fmt == "gzip" or fmt == "gz":                                         # kzip
            self.o = zlib.compressobj(wbits=31)                                  # kzip
        elif fmt == "bzip2" or fmt == "bz2":                                     # kzip
            self.o = bz2.BZ2Compressor()                                         # kzip
        else: raise Exception(f"File type {fmt} not supported. Specify either 'gz' or 'bz2'") # kzip
    def __ror__(self, it):                                                       # kzip
        o = self.o                                                               # kzip
        def gen():                                                               # kzip
            for e in it:                                                         # kzip
                if isinstance(e, str): e = f"{e}\n".encode()                     # kzip
                res = o.compress(e)                                              # kzip
                if res: yield res                                                # kzip
            try:                                                                 # kzip
                res = o.flush()                                                  # kzip
                if res: yield res                                                # kzip
            except: pass                                                         # kzip
        if isinstance(it, str): it = it.encode()                                 # kzip
        if isinstance(it, bytes): return [o.compress(it), o.flush()] | cli.filt("x") | cli.aS(b"".join) # kzip
        else: return gen()                                                       # kzip
class decompressobj:                                                             # decompressobj
    """
Why not just use zlib.decompressobj() directly? I encountered a strange bug when trying
to decompress CommonCrawl's gzip files, posted on Stack Overflow and got help from none
other than Mark Adler, creator of gzip and zlib. That guy's super active on Stack Overflow.
Anyway, this code here is a modified version of his code. Here's the discussion:
https://stackoverflow.com/questions/76452480/pythons-zlib-doesnt-work-on-commoncrawl-file
"""                                                                              # decompressobj
    def __init__(self, gz=True): self.gz = gz                                    # decompressobj
    def __ror__(self, it):                                                       # decompressobj
        gz = self.gz; data = left = b''; o = zlib.decompressobj(zlib.MAX_WBITS|32) if gz else bz2.BZ2Decompressor() # decompressobj
        for got in it:                                                           # decompressobj
            yield o.decompress(left + got); left = b''                           # decompressobj
            if o.eof: left = o.unused_data; o = zlib.decompressobj(zlib.MAX_WBITS|32) if gz else bz2.BZ2Decompressor() # decompressobj
            if len(got) == 0 and len(left) == 0: break                           # decompressobj
class kunzip(BaseCli):                                                           # kunzip
    def __init__(self, text=False):                                              # kunzip
        """Incrementally decompress a stream of data using gzip or bzip2.
Example::

    # returns an iterator of bytes. cat() command can shorten to cat("someFile.gz", False, True)
    cat("someFile.gz", text=False, chunks=True) | kunzip()
    # incrementally fetches remote file, then incrementally unzips it
    cat("https://example.com/someFile.gz", False, True) | kunzip()

    data = range(100) | apply(lambda x: str(x).encode()) | deref() # list of bytes
    data | kzip() | kunzip() | deref() # returns original data in list of bytes. May split the bytes at different positions though

How does it know which algorithm to pick to decompress? It looks at the
first few bytes of the file for its magic number. Also, if you're expecting
a text file after decompression, you can do this to get the lines directly::

    # returns iterator of strings
    cat("https://example.com/someFile.gz", False, True) | kunzip(True)

One more thing. If you're planning to use this to download whole files, you might
want to tune the chunk size in :data:`~k1lib.settings`.cli.cat.chunkSize as
it might speed things up considerably to raise it. Or may be you should just
use wget instead =))

More examples of the different styles to use this cli::

    ["abc"] | kzip() | kunzip(True) | deref() # returns ["abc"]
    "abc"   | kzip() | kunzip(True)           # returns  "abc"
    "abc"   | kzip() | kunzip()               # returns b"abc"

See also: :class:`kzip`. There's also an alias to this cli: :class:`unzip`

:param text: whether to yield string lines or bytes"""                           # kunzip
        self.text = text                                                         # kunzip
    def __ror__(self, it):                                                       # kunzip
        def gen(it):                                                             # kunzip
            it = iter(it); e = next(it); magic = puremagic.from_string(e).split(".")[-1] # kunzip
            if magic == "gz": o = decompressobj(True)                            # kunzip
            elif magic == "bz2": o = decompressobj(False)                        # kunzip
            else: raise Exception("Can't infer the file type (whether gz or bz2) of this file") # kunzip
            yield from [[e], it] | cli.joinStreams() | o                         # kunzip
        single = False                                                           # kunzip
        if isinstance(it, bytes): single = True; it = [it]                       # kunzip
        if self.text:                                                            # kunzip
            def gen2(it):                                                        # kunzip
                last = b"" # last split is probably not the right line boundary, so gotta do this # kunzip
                for e in gen(it):                                                # kunzip
                    e = last + e; splits = e.split(b"\n")                        # kunzip
                    for line in splits[:-1]: yield line.decode()                 # kunzip
                    last = splits[-1]                                            # kunzip
                yield last.decode()                                              # kunzip
            res = gen2(it)                                                       # kunzip
        else: res = gen(it)                                                      # kunzip
        if not single: return res                                                # kunzip
        else: return "\n".join(res) if self.text else b"".join(res)              # kunzip
unzip = kunzip                                                                   # kunzip
