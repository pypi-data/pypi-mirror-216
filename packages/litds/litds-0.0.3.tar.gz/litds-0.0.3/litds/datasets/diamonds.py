# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/datasets/00_diamonds.ipynb.

# %% auto 0
__all__ = ['make_diamond_quadrant', 'make_diamond', 'rotate_diamond', 'distance_from_origin', 'categorize_distances',
           'create_diamonds_dataset', 'create_diamonds_dataframe', 'DiamondsDataset', 'DiamondsDataModule']

# %% ../../nbs/datasets/00_diamonds.ipynb 3
import numpy as np, pandas as pd

import torch, torch.nn as nn, pytorch_lightning as pl
from torch.utils.data import DataLoader

import matplotlib as mpl, matplotlib.pyplot as plt, seaborn as sns

# %% ../../nbs/datasets/00_diamonds.ipynb 4
from dataclasses import dataclass, field, KW_ONLY
from beartype.typing import Optional, Tuple, Union, TypeAlias
from beartype import beartype
from littyping.core import Device

# %% ../../nbs/datasets/00_diamonds.ipynb 5
from iza.utils import wrangle_kwargs_for_func

#| export
from ..abc.dfdm.base import set_dataset
from ..utils import (random_split_dataframe)

# %% ../../nbs/datasets/00_diamonds.ipynb 6
from litds.types import (
    Number, DataFrame, IndexLike, SeriesLike, GroupKey,  
    TrainValidTestSplit,
    XYArray, DistanceArray, LabelArray,      
    SequenceWithLength, SequencesWithLengths
)

from ..time.base import (TimeDataset, TimeDataModule)

# %% ../../nbs/datasets/00_diamonds.ipynb 8
@beartype
def make_diamond_quadrant(
    n_points: int, width: Number=1, length: Number=1,
    is_left_half: bool=True, is_top_half: bool=True,
) -> XYArray:
    '''Generates a diamond quadrant.

    Args:
        n_points: number of points in the quadrant
        is_left_half: whether the quadrant is on the left half of the diamond
        is_top_half: whether the quadrant is on the top half of the diamond
        width: width of the diamond
        length: length of the diamond

    Returns:
        quadrant: the quadrant as a numpy array of shape (n_points, 2)
    '''
    half_width = width / 2
    half_height = length / 2
    
    # top left
    if is_left_half and is_top_half:
        x = np.linspace(-half_width, 0, n_points)
        y = np.linspace(half_height, length, n_points)

    # top right
    elif not is_left_half and is_top_half:
        x = np.linspace(half_width, 0, n_points)
        y = np.linspace(half_height, length, n_points)    

    # bottom left
    elif is_left_half and not is_top_half:
        x = np.linspace(0, -half_width, n_points)
        y = np.linspace(0, half_height, n_points)          

    # bottom right
    elif not is_left_half and not is_top_half:
        x = np.linspace(0, half_width, n_points)
        y = np.linspace(0, half_height, n_points)

    else:
        raise NotImplementedError

    quadrant = np.vstack((x, y)).T
    return quadrant

@beartype
def make_diamond(n_points: int, width: Number=1, length: Number=1) -> XYArray:
    '''Generates the four vertices of a diamond.'''
    # NOTE: n // 4 is the number of points in each quadrant
    n_quadrant = int(np.floor(n_points / 4)) 
    
    top_left: XYArray = make_diamond_quadrant(
        n_quadrant, width=width, length=length, is_left_half=True, is_top_half=True
    )

    top_right: XYArray = make_diamond_quadrant(
        n_quadrant, width=width, length=length, is_left_half=False, is_top_half=True
    )

    bottom_left: XYArray = make_diamond_quadrant(
        n_quadrant, width=width, length=length, is_left_half=True, is_top_half=False
    )

    bottom_right: XYArray = make_diamond_quadrant(
        n_quadrant, width=width, length=length, is_left_half=False, is_top_half=False
    )
    
    return np.vstack((top_left, top_right, bottom_left, bottom_right))

@beartype
def rotate_diamond(diamond: XYArray, rotation_angle: float) -> XYArray:
    '''Rotates a diamond by a given angle.'''
    rotation_matrix = np.array([[np.cos(rotation_angle), -np.sin(rotation_angle)], 
                                [np.sin(rotation_angle),  np.cos(rotation_angle)]])
    return np.matmul(diamond, rotation_matrix.T)

@beartype
def distance_from_origin(points: XYArray) -> DistanceArray:
    '''Calculates distance of points from the origin.'''
    return np.sqrt(np.sum(np.power(points, 2), axis=1))

@beartype
def categorize_distances(distances: DistanceArray, n_classes: int) -> LabelArray:
    '''Categorizes distances into n_classes classes.'''
    return pd.qcut(distances, q=n_classes, labels=False)

@beartype
def create_diamonds_dataset(
    n_diamonds: int, n_points: int, width: Number=1, length: Number=1,
    noise_level: float = 0., label_by_distance: bool=True, n_classes: Optional[int]=5
) -> Tuple[XYArray, LabelArray]:
    
    data = np.empty((0, 2))
    labels = np.empty(0, dtype=int)
    
    if n_classes is None:
        n_classes = n_diamonds

    for i in range(n_diamonds):
        diamond: XYArray = make_diamond(n_points, width=width, length=length)
        diamond = rotate_diamond(diamond, (2*np.pi/n_diamonds) * i)

        # add Gaussian noise
        diamond += np.random.normal(0, noise_level, np.array(diamond).shape)

        data: XYArray = np.vstack((data, diamond))

        if label_by_distance:            
            distances = distance_from_origin(diamond)
            labels: LabelArray = np.hstack((labels, categorize_distances(distances, n_classes)))
         
        else:
            labels: LabelArray = np.hstack((labels, np.full(n_points, i)))
            
    return data, labels

@beartype
def create_diamonds_dataframe(
    n_diamonds: int = 5, n_points: int = 400, width: Number=1, length: Number=1,
    noise_level: float = 0., label_by_distance: bool=True, n_classes: Optional[int]=5,
    label_key: str = 'label', use_index: bool = True
) -> pd.DataFrame:    
    x, y = create_diamonds_dataset(
        n_diamonds, n_points, width, length,
        noise_level, label_by_distance, n_classes
    )
    df = pd.DataFrame(x, columns=['x', 'y'], index=pd.Series(y, name=label_key))
    if not use_index:
        df.reset_index(inplace=True)
    return df

# %% ../../nbs/datasets/00_diamonds.ipynb 12
@dataclass
class DiamondsDataset(TimeDataset):
    n_diamonds: int = 5
    n_points: int = 400 
    width: Number = 0.5
    length: Number = 1
    noise_level: float = 0.025
    label_by_distance: bool = True 
    n_classes:  Optional[int] = 5
    
    _: KW_ONLY = field(default=None, init=False)
    include_time: Optional[bool] = False
    device: Optional[Device] = None

    def __init__(self, *args, **kwargs) -> None:
        df = kwargs.pop('df', None)
        if df is None:
            params = dict(
                n_diamonds=self.n_diamonds, n_points=self.n_points, 
                width=self.width, length=self.length,
                noise_level=self.noise_level, label_by_distance=self.label_by_distance, 
                n_classes=self.n_classes, label_key=self.time_key, use_index=False
            )        
            params = wrangle_kwargs_for_func(create_diamonds_dataframe, params, **kwargs)
            df = create_diamonds_dataframe(**params)
        self.df = df
        super().__init__(df=df)

    def __post_init__(self):
        super().__post_init__()

    def plot(self, figsize=(4, 4), palette='magma'):
        plt.figure(figsize=figsize)
        sns.scatterplot(data=self.df, x='x', y='y', hue=self.time_key, palette=palette)
        plt.show()

# %% ../../nbs/datasets/00_diamonds.ipynb 16
@dataclass
@set_dataset(DiamondsDataset)
class DiamondsDataModule(TimeDataModule):
    n_diamonds: int = 5
    n_points: int = 400 
    width: Number = 0.5
    length: Number = 1
    noise_level: float = 0.025
    label_by_distance: bool = True 
    n_classes:  Optional[int] = 5

    perc_train: float = 0.7
    perc_valid: float = 0.1
    perc_test:  float = 0.2

    _: KW_ONLY = field(default=None, init=False)
    include_time: Optional[bool] = False
    device: Optional[Device] = None
    
    def prepare_data(self, *args, **kwargs):
        df = create_diamonds_dataframe(
            self.n_diamonds, self.n_points, self.width, self.length,
            self.noise_level, self.label_by_distance, self.n_classes,
            label_key=self.time_key, use_index = False
        )
        self.df = df

        self.splits = TrainValidTestSplit(self.perc_train, self.perc_valid, self.perc_test)
        return self
    
    def setup(self, stage: Optional[str]=None):
        self.prepare_data()

        df_tmp = self.df
        if not self.include_time:
            df_tmp = df_tmp.drop(columns=self.time_key, errors='ignore')
        
        idxs_train, idxs_valid, idxs_test = random_split_dataframe(
            df_tmp, self.splits, as_dataframes=False
        )

        self.idxs_train = idxs_train
        self.idxs_valid = idxs_valid
        self.idxs_test = idxs_test
        
        if stage == 'fit':
            pass
        
        if stage == 'test':
            pass
        
        if stage == 'predict':
            pass

    def collate_fn(self, batch):
        seqs, lens = zip(*batch)
        seqs = torch.stack(seqs)
        lens = torch.stack(lens)
        return seqs, lens

    def train_dataloader(self):
        ds = self.make_dataset(df=self.df.iloc[self.idxs_train])
        self.train_ds = ds
        return DataLoader(ds, batch_size=self.batch_size, collate_fn=self.collate_fn)
    
    def val_dataloader(self):
        ds = self.make_dataset(df=self.df.iloc[self.idxs_valid])
        self.valid_ds = ds
        return DataLoader(ds, batch_size=self.batch_size, collate_fn=self.collate_fn)
    
    def test_dataloader(self):
        ds = self.make_dataset(df=self.df.iloc[self.idxs_test])
        self.test_ds = ds
        return DataLoader(ds, batch_size=self.batch_size, collate_fn=self.collate_fn)    
