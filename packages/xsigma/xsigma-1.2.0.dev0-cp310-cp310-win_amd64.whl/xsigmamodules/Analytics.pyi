from typing import overload, Any, Callable, TypeVar, Union
from typing import Tuple, List, Sequence, MutableSequence

Callback = Union[Callable[..., None], None]
Buffer = TypeVar('Buffer')
Pointer = TypeVar('Pointer')
Template = TypeVar('Template')

import xsigmamodules.Core
import xsigmamodules.Market

class parameter_markovian_hjm_type(int):
    HULL_WHITE:'parameter_markovian_hjm_type'
    PICEWISE_CONSTANT:'parameter_markovian_hjm_type'

class bermudanStrikesLifeCycle(xsigmamodules.Market.lifeCycleData):
    @overload
    def excution_boundary_strikes(self, index:int) -> float: ...
    @overload
    def excution_boundary_strikes(self) -> Tuple[float, float]: ...

class calibrationBlackKarasinskiSettings(xsigmamodules.Market.configData):
    def backward(self) -> bool: ...
    def debug(self) -> bool: ...
    def json_to_string(rhs:'calibrationBlackKarasinskiSettings') -> str: ...
    def level_lower_bound(self) -> float: ...
    def level_upper_bound(self) -> float: ...
    def mean_reversion_spead(self) -> float: ...
    def minimum_step(self) -> float: ...
    def pde_grid_size(self) -> int: ...
    def pde_span(self) -> float: ...
    def period(self) -> int: ...
    def read_from_binary(file_name:str) -> 'calibrationBlackKarasinskiSettings': ...
    def read_from_json(file_name:str) -> 'calibrationBlackKarasinskiSettings': ...
    def step(self) -> float: ...
    def tolerance(self) -> float: ...
    def update_bounds(self) -> bool: ...
    def use_adjustement(self) -> bool: ...
    def write_to_binary(file_name:str, rhs:'calibrationBlackKarasinskiSettings') -> None: ...
    def write_to_json(file_name:str, rhs:'calibrationBlackKarasinskiSettings') -> None: ...

class calibrationCheyetteSettings(xsigmamodules.Market.configData):
    def debug(self) -> bool: ...
    def json_to_string(rhs:'calibrationCheyetteSettings') -> str: ...
    def read_from_binary(file_name:str) -> 'calibrationCheyetteSettings': ...
    def read_from_json(file_name:str) -> 'calibrationCheyetteSettings': ...
    def tolerance(self) -> float: ...
    def type(self) -> 'parameterMarkovianHjmType': ...
    def write_to_binary(file_name:str, rhs:'calibrationCheyetteSettings') -> None: ...
    def write_to_json(file_name:str, rhs:'calibrationCheyetteSettings') -> None: ...

class calibrationCreditBlackKarasinski(object): ...

class calibrationHjmSettings(xsigmamodules.Market.configData):
    def debug(self) -> bool: ...
    def json_to_string(rhs:'calibrationHjmSettings') -> str: ...
    def read_from_binary(file_name:str) -> 'calibrationHjmSettings': ...
    def read_from_json(file_name:str) -> 'calibrationHjmSettings': ...
    def tolerance(self) -> float: ...
    def type(self) -> 'parameterMarkovianHjmType': ...
    def write_to_binary(file_name:str, rhs:'calibrationHjmSettings') -> None: ...
    def write_to_json(file_name:str, rhs:'calibrationHjmSettings') -> None: ...

class calibrationIrCheyette(object):
    def calibrate(self, volatility_surface:'irVolatilitySurface', settings:'calibrationCheyetteSettings', parameter_hjm:'parameterMarkovianHjm') -> 'parameterCheyette': ...
    def swaptions(self) -> Tuple['calibrationIrCheyetteSwaption', 'calibrationIrCheyetteSwaption']: ...

class calibrationIrHjm(object):
    def calibrate(self, volatility_surface:'irVolatilitySurface', correlation:'matrix_IdE', settings:'calibrationHjmSettings', strikes:Sequence[float]=..., initial_parameter:'parameterMarkovianHjm'=...) -> 'parameterMarkovianHjm': ...
    def swaptions(self) -> Tuple['calibrationIrHjmSwaption', 'calibrationIrHjmSwaption']: ...

class calibrationIrTargetsConfiguration(xsigmamodules.Market.configData):
    def cms_tenors(self) -> Tuple['tenor', 'tenor']: ...
    def coterminal(self) -> 'tenor': ...
    def expiries(self) -> Tuple['tenor', 'tenor']: ...
    def frequency(self) -> 'tenor': ...
    def include_caplets(self) -> bool: ...
    def include_cms(self) -> bool: ...
    def include_coterminal(self) -> bool: ...
    def json_to_string(rhs:'calibrationIrTargetsConfiguration') -> str: ...
    def read_from_binary(file_name:str) -> 'calibrationIrTargetsConfiguration': ...
    def read_from_json(file_name:str) -> 'calibrationIrTargetsConfiguration': ...
    def write_to_binary(file_name:str, rhs:'calibrationIrTargetsConfiguration') -> None: ...
    def write_to_json(file_name:str, rhs:'calibrationIrTargetsConfiguration') -> None: ...

class correlationManager(xsigmamodules.Market.marketData):
    def id(self, i:int) -> 'diffusionId': ...
    def ids(self) -> Tuple['diffusionId', 'diffusionId']: ...
    def json_to_string(rhs:'correlationManager') -> str: ...
    def number_of_factors(self, id:'diffusionId') -> int: ...
    def pair_correlation_matrix(self, ids1:Sequence['diffusionId'], ids2:Sequence['diffusionId']) -> 'matrix_IdE': ...
    def read_from_binary(file_name:str) -> 'correlationManager': ...
    def read_from_json(file_name:str) -> 'correlationManager': ...
    def write_to_binary(file_name:str, rhs:'correlationManager') -> None: ...
    def write_to_json(file_name:str, rhs:'correlationManager') -> None: ...

class instrument(object):
    def make_life_cycle_data(self) -> 'lifeCycleData': ...
    def size(self) -> int: ...
    def value(self, expiry:'datetime', mkt_data:Sequence['marketData'], output:'tensor_IdE') -> None: ...

class instrumentBermudanSwaption(instrument):
    def make_life_cycle_data(self) -> 'lifeCycleData': ...
    def size(self) -> int: ...
    def swaptoins(self) -> Tuple['instrumentIrSwaption', 'instrumentIrSwaption']: ...
    def value(self, expiry:'datetime', mkt_data:Sequence['marketData'], output:'tensor_IdE') -> None: ...

class instrumentCreditBond(instrument):
    def convention(self) -> 'dayCountConvention': ...
    def maturity(self) -> 'datetime': ...
    def size(self) -> int: ...
    def value(self, expiry:'datetime', mkt_data:Sequence['marketData'], output:'tensor_IdE') -> None: ...

class instrumentIrBond(instrument):
    def convention(self) -> 'dayCountConvention': ...
    def maturity(self) -> 'datetime': ...
    def size(self) -> int: ...
    def value(self, expiry:'datetime', mkt_data:Sequence['marketData'], output:'tensor_IdE') -> None: ...

class instrumentIrSwaption(instrument):
    def is_call(self) -> bool: ...
    def size(self) -> int: ...
    def strikes(self) -> Tuple[float, float]: ...
    def swap(self) -> 'interestRateSwap': ...
    def value(self, expiry:'datetime', mkt_data:Sequence['marketData'], output:'tensor_IdE') -> None: ...

class interestRateSwap(object):
    def all_dates(self) -> Tuple['datetime', 'datetime']: ...
    @overload
    def annuity(self, dfs:Sequence[float]) -> float: ...
    @overload
    def annuity(self) -> float: ...
    def expiry(self) -> 'datetime': ...
    @overload
    def implied_volatility(self, value:float, strike:float, is_call:float=1) -> float: ...
    @overload
    def implied_volatility(self, volatility_surface:'irVolatilitySurface', strike:float) -> float: ...
    def is_caplet(self) -> bool: ...
    def maturity(self) -> 'datetime': ...
    def simulated_value(self, mm:'vector_IdE', curve:'discountCurve', strikes:Sequence[float], is_call:bool, moment_matching:bool, debug:bool) -> Tuple[float, float]: ...
    @overload
    def swap_rate(self, dfs:Sequence[float]) -> float: ...
    @overload
    def swap_rate(self) -> float: ...
    def value(self, strike:float, dfs:Sequence[float]) -> float: ...

class lognormalModelWithMhjmIr(object):
    def calibrate(self, calibration_dates:Sequence['datetime'], market_variance:Sequence[float], day_convention:'dayCountConvention') -> 'parameterLognormal': ...

class lognormalEquityWithMhjmIr(lognormalModelWithMhjmIr): ...

class lognormalFxWithMhjmIr(lognormalModelWithMhjmIr): ...

class parameterBlackKarasinski(xsigmamodules.Core.aadStateParametersManager):
    def json_to_string(rhs:'parameterBlackKarasinski') -> str: ...
    def levels_parameter_offset(self, t:'datetime') -> int: ...
    def parameters(self) -> 'parameterMarkovianHjm': ...
    def read_from_binary(file_name:str) -> 'parameterBlackKarasinski': ...
    def read_from_json(file_name:str) -> 'parameterBlackKarasinski': ...
    def write_to_binary(file_name:str, rhs:'parameterBlackKarasinski') -> None: ...
    def write_to_json(file_name:str, rhs:'parameterBlackKarasinski') -> None: ...

class parameterCheyette(xsigmamodules.Core.aadStateParametersManager):
    def json_to_string(rhs:'parameterCheyette') -> str: ...
    def long_term_skew_level(self) -> float: ...
    def parameters(self) -> 'parameterMarkovianHjm': ...
    def read_from_binary(file_name:str) -> 'parameterCheyette': ...
    def read_from_json(file_name:str) -> 'parameterCheyette': ...
    def skew_parameter(self) -> 'matrix_IdE': ...
    def skew_parameter_dates(self) -> Tuple['datetime', 'datetime']: ...
    def write_to_binary(file_name:str, rhs:'parameterCheyette') -> None: ...
    def write_to_json(file_name:str, rhs:'parameterCheyette') -> None: ...

class parameterExtendedCir(xsigmamodules.Core.aadStateParametersManager):
    def correlation(self) -> 'matrix_IdE': ...
    def day_convention(self) -> 'dayCountConvention': ...
    def json_to_string(rhs:'parameterExtendedCir') -> str: ...
    def mean_reversion_speed_dates(self) -> Tuple['datetime', 'datetime']: ...
    def mean_reversion_speeds(self) -> 'matrix_IdE': ...
    def read_from_binary(file_name:str) -> 'parameterExtendedCir': ...
    def read_from_json(file_name:str) -> 'parameterExtendedCir': ...
    def shifts(self) -> 'matrix_IdE': ...
    def shifts_dates(self) -> Tuple['datetime', 'datetime']: ...
    def volatilities(self) -> 'matrix_IdE': ...
    def volatilities_dates(self) -> Tuple['datetime', 'datetime']: ...
    def write_to_binary(file_name:str, rhs:'parameterExtendedCir') -> None: ...
    def write_to_json(file_name:str, rhs:'parameterExtendedCir') -> None: ...

class parameterLognormal(xsigmamodules.Core.aadStateParametersManager):
    def correlation(self) -> 'matrix_IdE': ...
    def day_convention(self) -> 'dayCountConvention': ...
    def json_to_string(rhs:'parameterLognormal') -> str: ...
    def number_of_factors(self) -> int: ...
    def read_from_binary(file_name:str) -> 'parameterLognormal': ...
    def read_from_json(file_name:str) -> 'parameterLognormal': ...
    def volatilities(self) -> 'matrix_IdE': ...
    def volatilities_dates(self) -> Tuple['datetime', 'datetime']: ...
    def write_to_binary(file_name:str, rhs:'parameterLognormal') -> None: ...
    def write_to_json(file_name:str, rhs:'parameterLognormal') -> None: ...

class parameterMarkovianHjm(xsigmamodules.Core.aadStateParametersManager):
    def correlation(self) -> 'matrix_IdE': ...
    def day_convention(self) -> 'dayCountConvention': ...
    def decays(self) -> 'matrix_IdE': ...
    def decays_dates(self) -> Tuple['datetime', 'datetime']: ...
    def json_to_string(rhs:'parameterMarkovianHjm') -> str: ...
    def model_type(self) -> 'parameterMarkovianHjmType': ...
    def number_of_factors(self) -> int: ...
    def read_from_binary(file_name:str) -> 'parameterMarkovianHjm': ...
    def read_from_json(file_name:str) -> 'parameterMarkovianHjm': ...
    def scale_volatilities(self, scaling_factors:'matrix_IdE') -> None: ...
    def volatilities(self) -> 'matrix_IdE': ...
    def volatilities_dates(self) -> Tuple['datetime', 'datetime']: ...
    def write_to_binary(file_name:str, rhs:'parameterMarkovianHjm') -> None: ...
    def write_to_json(file_name:str, rhs:'parameterMarkovianHjm') -> None: ...

class randomConfig(xsigmamodules.Market.configData):
    def json_to_string(rhs:'randomConfig') -> str: ...
    def main_generator_type(self) -> 'randomType': ...
    def read_from_binary(file_name:str) -> 'randomConfig': ...
    def read_from_json(file_name:str) -> 'randomConfig': ...
    def settings(self) -> 'randomSettings': ...
    def write_to_binary(file_name:str, rhs:'randomConfig') -> None: ...
    def write_to_json(file_name:str, rhs:'randomConfig') -> None: ...

